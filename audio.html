<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
    <link href="css/style.css" rel="stylesheet" />
  </head>
  <body>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-1">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。パート1：音楽/SFXエンジンを作る</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b><font size="5">APUについて</font></b><br>
        <br>
        ファミコンの音楽や効果音は、CPUに内蔵された<b>APU</b>（Audio Processing Unit）というサウンドチップによって生成されます。 CPUは、PPUやジョイパッドと同じように、一連のI/Oポートを通じてAPUと「会話」しています。<br>
        <br>
        PPU：2000ドル〜2007ドル<br>
        ジョイパッド：4016ドル～4017ドル<br>
        APU：4000ドル～4015ドル、4017ドル<br>
        <br>
       <b><font size="4">チャンネル</font></b><br>
        <br>
        APUには5つのチャンネルがあります。スクエア1、スクエア2、トライアングル、ノイズ、DMCです。 最初の4つはウェーブを再生し、ほぼすべてのゲームで使用されます。 DMCチャンネルはサンプル（録音された音）を再生しますが、使用頻度は低くなっています。<br>
        <br>
       <b><font size="3"><font size="2">スクエア</font></font></b><br>
        Squareチャンネルは矩形波形を生成します。 矩形波はその形状から名付けられました。 以下のような形をしています。<br>
        <div id="j.ge" style="text-align: left">
          <img src="img/square_wave.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/square_wave.jpg" show-src="img/square_wave.jpg">
        </div>
        <br>
        木管楽器やエレキギターのような空洞のあるサウンドを生み出します。<br>
        <br>
       <b><font size="3"><font size="2">トライアングル</font></font></b><br>
        三角波を生成するチャンネルです。 三角波は、その形状から名づけられました。 このような形状です。<br>
        <div id="rnep" style="text-align: left">
          <img src="img/triangle_wave.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/triangle_wave.jpg" show-src="img/triangle_wave.jpg">
        </div>
        <br>
        矩形波と比べると、滑らかでキツくない音になります。ファミコンでは、ベースライン（低音）やフルート（高音）によく使われます。 また、ドラムにも使用できます。<br>
        <br>
       <font size="2"><b>ノイズ</b></font><br>
        ノイズチャンネルはランダムジェネレーターを備えており、生成される波はノイズのように聞こえます。 このチャンネルは一般的にパーカッションや爆発音に使用されます。<br>
        <br>
       <font size="2"><b>DMC</b></font><br>
        DMCチャンネルはサンプル音（録音された音）を再生します。 音声録音（「Blades of Steel」）やパーカッションサンプルの再生によく使われます。 サンプルは多くのROMスペースを取るので、DMCチャンネルを使用するゲームは多くありません。<br>
        <br>
        <br>
       <b><font size="4">チャンネルを有効にする</font></b><br>
        <br>
        チャンネルを使って音を出す前に、チャンネルを有効にする必要があります。 チャンネルは、ポート $4015 を使ってオン・オフを切り替えます。<br>
        <br>
       <span style="font-family: Courier New">apuflags ($4015)</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">76543210</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> |||||</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> ||||+- 四角形1 (0: 無効、1: 有効)</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> |||+-- 四角形2</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> |||+--- 三角形</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> |+----- ノイズ</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> +----- DMC</span><br>
        <br>
        以下は、$4015を使用してチャンネルを有効化および無効化するコード例です。<br>
        <br>
       <span style="font-family: Courier New"> lda #%00000001</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4015 ;スクエア1チャンネルを有効、その他を無効にする。</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> </span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #%00010110</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4015 ;矩形2、三角、DMCチャンネルを有効、矩形1、ノイズを無効</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> </span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4015 ;全チャンネル無効化</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> </span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #$0F</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4015 ;矩形1、矩形2、三角、ノイズの各チャンネルを有効にする。 DMCを無効にする。</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> 最も一般的な使用方法です。</span><br>
        <br>
        FCEUXD SPで好きなゲームを開いて、$4015への書き込みにブレークポイントを設定してみてください。 そこにどんな値が書き込まれているか見てみましょう。 もし、この方法がわからない場合は、以下のステップを踏んでください。<br>
        <br>
        1.FCEUXD SPを開く。<br>
        2.ROMをロードする。<br>
        3.F1キーを押すか、ツール-&gt;デバッガでデバッガを起動します。<br>
        4.4. デバッガ右上の「ブレークポイント」の下にある「追加」ボタンをクリックします。<br>
        5."Address: "の後の最初のボックスに "4015 "と入力します。<br>
        6."Write "の横のチェックボックスにチェックを入れる<br>
        7.7. "Memory "を "CPU Mem "に設定する。<br>
        8.8. "Condition "と "Name "を空白にし、"OK "をクリックする。<br>
        <br>
        FCEUXはエミュレーションを一時停止し、ゲームが4015ドルに書き込みを行うたびにデバッガーをスナップします。 デバッガーはその時のレジスタの内容を表示しますので、4015ドルに書き込まれる値を確認できます。 ゲームによっては、毎フレーム4015ドルに書き込むものと、起動時に1回だけ行うものがあります。 デバッガーをスナップしない場合は、ゲームをリセットしてみてください。<br>
        <br>
        4015に書き込まれている値は何ですか？ ゲームが使用しているチャンネルは分かりますか？<br>
        <br>
        <br>
       <b><font size="4">スクエア1チャンネル</font></b><br>
        <br>
        ビープ音を出してみましょう。 今週は、Square 1チャンネルで音を出す方法を学びます。 Squareチャンネルは、ボリュームとトーンをコントロールでき、スイープを実行できるので、みんなのお気に入りです。 Squareを使うと、たくさんの面白いエフェクトを作ることができます。<br>
        <br>
        Square 1は、ポート4000-4003で制御します。 最初のポート4000は、このチャンネルのデューティ・サイクル（つまりトーン）とボリュームを制御します。 以下のような感じです。<br>
        <br>
       <span style="font-family: Courier New">SQ1_ENV ($4000)</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">76543210</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||++- ボリューム</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">|||+----- Saw Envelope Disable (0: ボリュームに内部カウンタを使用; 1: ボリュームにボリュームを使用)</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">|||+------ Length Counter Disable (0: Length Counterを使用、1: Length Counterを使用しない)</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">++------- デューティーサイクル</span><br>
        <br>
        今回は、VolumeとDuty Cycleに注目します。 Saw Envelope DisableとLength Counter Disableを1にセットして、あとは忘れてしまいましょう。 Saw Envelopeがオンのままだと、チャンネルのボリュームは内部カウンターでコントロールされます。 これをオフにすると、ボリュームは私たちがコントロールすることになります。私たちがコントロールできれば、独自のエンベロープをコーディングすることができます（より汎用性があります）。 Length Counterも同様です。 これを無効にすれば、私たちはノートの長さをよりコントロールできます。 意味が分からなくても心配しないでください。 後で明らかになります。 今は、これらを無効にして忘れることにしましょう。<br>
        <br>
       <i>Volumeは</i>、チャンネルの音量をコントロールします。 4ビットなので、0からFまでの値を設定できます。0はチャンネルを無音にし、1は非常に小さく、Fは大きくします。<br>
        <br>
       <i>Duty Cycleは</i>Squareチャンネルの音色を制御します。 2ビット長なので、4つの値が可能です。<br>
        <br>
        00 = 弱く、粒状のトーン。 RCプロアマのエンジン音をイメージしてください。(デューティ12.5%)<br>
        01 = 固い中間の強さのトーンです。(25%デューティ)<br>
        10 = クラリネットやリードギターのような力強いフルトーン（デューティ50％）。<br>
        11 = 01によく似た音色（25% Dutyを否定したもの）<br>
        <br>
       <a href="http://famitracker.shoodot.net/" target="_blank" original-href="http://famitracker.shoodot.net/">FamiTrackerを</a>ダウンロードし、インストゥルメントエディターでDutyの設定を変えてみることをお勧めします。<br>
        <br>
        デューティ・サイクルとは、波が「上」の位置にある時間と「下」の位置にある時間の割合を指します。 以下、写真をご覧ください。<br>
        <br>
        12.5%     <div id="f0:l" style="text-align: left">
          <img src="img/square_wave_125_duty.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/square_wave_125_duty.jpg" show-src="img/square_wave_125_duty.jpg">
        </div>
        25%<br><br>
        <div id="ilti" style="text-align: left">
          <img src="img/square_wave_25_duty.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/square_wave_25_duty.jpg" show-src="img/square_wave_25_duty.jpg">
        </div>
        50%<br><br>
        <div id="bjx0" style="text-align: left">
          <img src="img/square_wave_50_duty.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/square_wave_50_duty.jpg" show-src="img/square_wave_50_duty.jpg">
        </div>
        25% 否定<br><br>
        <div id="qi76" style="text-align: left">
          <img src="img/square_wave_25neg_duty.jpg" style="width: 240px; height: 50px" original-src="http://tummaigames.com/square_wave_25neg_duty.jpg" show-src="img/square_wave_25neg_duty.jpg">
        </div>
        <br>
        グラフや波が苦手でも大丈夫。 代わりに耳で聞いてみてください。<br>
        <br>
        以下は、Square 1 チャンネルのデューティとボリュームを設定するコードスニペットです。<br>
        <br>
       <span style="font-family: Courier New"> lda #%10111111; デューティー10（50％）、ボリュームF（最大！）。</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4000</span><br>
        <br>
        4001はSquare 1のスイープを制御します。 今は省略します。<br>
        <br>
       <font size="2"><b>ノートの設定</b></font><br>
        4002と4003は、波の周期、言い換えれば、聞こえる音（A、C#、Gなど）をコントロールします。 周期は11ビットで、4002は周期の下位8ビット、4003は上位3ビットを保持します。 今後のチュートリアルでより詳細に説明しますが、今は、これらのポートに書き込む値を変更すると再生する音が変わることだけを知っておいてください。<br>
        <br>
       <span style="font-family: Courier New">SQ1_LO ($4002)</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">76543210</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">++++++++- 周期の下位8ビット</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">SQ1_HI ($4003)</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">76543210</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||+++- 期間中の上位3ビット</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">+++++---- 長さカウンタ</span><br>
        <br>
        長さカウンターは、有効であれば、ノートが再生される長さを制御します。 私たちは4000ドルのセクションでそれを無効にしたので、今はそれを忘れてもかまいません。<br>
        <br>
        以下は、Square 1チャンネルで永遠のビープ音を鳴らすコードです。<br>
        <br>
       <span style="font-family: Courier New"> LDA #%00000001</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4015 ;スクウェア1を有効にする</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> </span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #%10111111 ;デューティ10、ボリュームF</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4000</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> </span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #$C9 ;0C9はNTSCモードではC#です。</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4002</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New">
       <span style="font-family: Courier New"> sta $4003</span><br>
        <br>
       <b>まとめ方</b><br>
        サンプルファイル<a href="downloads/NerdyNightsSoundSourceCollection/square1.zip" target="_blank" original-href="http://tummaigames.com/square1.zip">square1.zipを</a>ダウンロードして解凍してください。上記のコードは全てsquare1.asmの中に入っています。square1.asm と square1.bat がすべて NESASM3 と同じフォルダにあることを確認し、 square1.bat をダブルクリックします。これでNESASM3が実行され、square1.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行してビープ音を聞いてみましょう！ square1.asmを編集してボリューム（0〜F）を変更したり、矩形波のデューティサイクルを変更します。 周期を変えていろいろな音を出してみてください。<br>
        <br>
       <b>次回は</b>、<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22610" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22610">矩形波2と三角波です。 複数の</a>ビープ音を鳴らす      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-1__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22484" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-2">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。第2回：スクエア2、トライアングルの基礎知識</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22484" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22484">APUの概要とSquare 1の基礎</a>知識<br><br><b>今週は</b>Square 2とTriangleチャンネルを使った音の作り方を学びます。<br><br><font size="4" style="font-weight: bold">スクエア2</font><br><br>前回は、Square 1チャンネルで、$4000-$4003に書き込みをしてビープ音を作りましたが、今度はSquare 2でそれを作る方法を学びます。 これはとても簡単です。 Square 2チャンネルはポート$4004-$4007でコントロールしますが、これらはSquare 1の$4000-4003とほぼ同じものだからです。<br><br><span style="font-family: Courier New"><b>sq2_env</b>($4004)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||++- ボリューム</span><br style="font-family: Courier New"><span style="font-family: Courier New">|||+----- Saw Envelope Disable (0: ボリュームに内部カウンタを使用; 1: ボリュームにボリュームを使用)</span><br style="font-family: Courier New"><span style="font-family: Courier New">|||+------ Length Counter Disable (0: Length Counterを使用、1: Length Counterを使用しない)</span><br style="font-family: Courier New"><span style="font-family: Courier New">++------- デューティサイクル</span><br><br>
        <br><span style="font-family: Courier New"><b>sq2_sweep</b>($4005)</span><br>とりあえずスキップしてください。 ちなみにこのポートは、スクエア2とスクエア1が異なるところです。<br><br style="font-family: Courier New"><span style="font-family: Courier New"></span><span style="font-family: Courier New"><b><br>
           </b><b>SQ2_LO</b>($4006)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">++++++++- ピリオドの下位8ビット</span><br><br><span style="font-family: Courier New"></span><span style="font-family: Courier New"><b><br>
           </b><b>SQ2_HI</b>($4007)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||+++- 期間中の上位3ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New">+++++---- 長さカウンタ</span><br><br>音を出すために、まず、4015ドル経由でチャンネルを有効にします。<br><br><span style="font-family: Courier New"> LDA #%00000010 ;スクエア2を有効にする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015</span><br><br>次に、Square 2のポートに書き込む。<br><br><span style="font-family: Courier New"> lda #%00111000 ;デューティサイクル00、ボリューム8（ハーフボリューム）</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4004</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$A9 ;$0A9はNTSCモードではEです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4006</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4007</span><br><br>スイープ以外は、Square1チャンネルと同じように動作します。<br><br><b><font size="4">トライアングル</font></b><br><br>Triangleチャンネルは、滑らかなサウンドを持つ三角形の波形を生成します。 Dragon Warriorのオーバーランドソングのフルートのようなメロディーを思い浮かべてください。 それがTriangleです。<br><br>Squareチャンネルとは異なり、Triangleチャンネルの音量や音色はコントロールできません。 音は1種類だけで、オン（再生）かオフ（無音）です。 Triangleチャンネルを操作するには、ポート4008-$400Bを使用します。<br><br style="font-family: Courier New"><span style="font-family: Courier New">tri_ctrl ($4008)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">|+++++++- 値</span><br style="font-family: Courier New"><span style="font-family: Courier New">+-------- 制御フラグ (0: 内部カウンタを使用; 1: 内部カウンタを無効にする)</span><br><br>三角波チャンネルには、音符の長さを自動的に制御するために使用できる2つの内部カウンタがあります。 ここでは、音符の長さを手動で制御できるように、それらを無効にします。<b>Control Flagを</b>1にセットして、忘れることにします。<br><br>内部カウンターを無効にすると、<b>Valueが</b>チャンネルのオン/オフを制御します。 チャンネルを消音するには、Valueを0に設定します。 チャンネルをオンにするには（つまり消音）、Valueに0以外の値を設定します。 以下は、いくつかの例です。<br><br><span style="font-family: Courier New"> lda #%10000000 ;トライアングルチャネルを無音にする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10000001 ;トライアングルチャネルをオンにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10001111 ;三角形のチャンネルをオンにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%11111111 ;三角形のチャンネルをオンにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br><br>最後の3つの例は、機能的に同じであることに注意してください。 Valueに0以外の値を指定すると、Triangleチャンネルが再生されます。<br><br><b>未使用のポート</b><br>4009は未使用です。<br><br><b>ノートの設定</b><br>400Aと400Bは、波の周期、つまりA, C#, Gなどの音をコントロールします。 Squaresと同様、Triangleの周期は11ビットです。 400Aは周期の下位8ビット、400Bは上位3ビットを保持します。周期については来週詳しく説明しますが、今は、これらのポートに書き込む値を変更すると再生する音が変わることを知っておいてください。<br><br><span style="font-family: Courier New">TRI_LO ($400A)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">++++++++- ピリオドの下位8ビット</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">TRI_HI ($400B)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||+++- 期間中の上位3ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New">+++++---- 長さカウンタ</span><br><br>長さカウンターは、有効にすると、音が再生される長さを制御します。 4008のセクションで無効にしたので、今は忘れても大丈夫です。<br><br>以下は、Triangleチャンネルで永遠のビープ音を再生するコードです。<br><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%00000100 ;トライアングルチャンネルを有効にする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10000001 ;カウンターを無効にする、0以外の値でチャンネルをオンにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$42 ;NTSCモードでは$042の周期でG#が再生される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400A</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400B</span><br><br><font size="4"><b>複数のビープ音</b></font><br>これで、Square1、Square2、Triangleチャンネルを使って音を出す方法がわかりました。 全部同時に演奏させるには、4015ドルで3つのチャンネルを有効にして、ポートに書き込むだけです。 以下に、今までの知識を使ってC#mコード（C# E G#）を演奏するコードを見てみましょう。<br><br><span style="font-family: Courier New"> lda #%00000111 ;Sq1、Sq2、Triチャンネルを有効にする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> スクエア1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%00111000 ;デューティ00、ボリューム8(ハーフボリューム)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$C9 ;$0C9はNTSCモードではC#である</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002 ;ピリオドの下位8ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003 ;期間の上位3ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> スクエア2</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%01110110 ;デューティ01、ボリューム6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4004</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$A9 ;$0A9はNTSCモードではEになる</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4006</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4007</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> 三角形</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10000001 ;三角形のチャンネルオン</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$42 ;$042はNTSCモードではG#です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400A</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400B</span><br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/triad.zip" target="_blank" original-href="http://tummaigames.com/triad.zip">triad.zipの</a>サンプルファイルをダウンロードして解凍してください。上記のコードはすべて triad.asm ファイルに含まれています。triad.asmとtriad.batがすべてNESASM3と同じフォルダにあることを確認し、triad.batをダブルクリックします。これでNESASM3が実行され、triad.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行してC#mコードを聴いてみましょう！ triad.asmを編集して矩形波のボリュームとデューティサイクルを変えてみましょう。 周期を変えて別の音を出してみてください。<br><br>4015で無効にするか、4000/$4004/$4008で無音にするか、いろいろなチャンネルを無音にしてみてください。<br><br>最後に、ユーザーの入力に応じて、各チャンネルを消音／消音するコードを書いてみてください。<br><br><span style="font-weight: bold">A</span>: スクエア1チャンネルのオン/オフ切り替え<br><span style="font-weight: bold">B</span>: スクエア2チャンネルのオン/オフの切り替え<br><span style="font-weight: bold">選択</span>：三角形チャンネルのオン／オフの切り替え<br><br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22776" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22776">周期とルックアップテーブル</a><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-2__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22610" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-3">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。第3回：ピリオドとルックアップテーブル</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22610" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22610">スクエア2、トライアングルの基本</a><br><br><b>今週は</b>ピリオドについて学び、8オクターブにまたがるピリオドのルックアップテーブルを作成します。<br><br><b><font size="4">ピリオド</font></b><br><br>ここ2回のレッスンで、SquareとTriangleチャンネルの11ビットピリオドに差し込む値を示しましたが、ピリオドとは何か、またその値をどこから得たかについては説明していません。 そこで今週は、ピリオドについて学びます。<br><b><br>
          ピリオドとは？</b><br>周期とは、波の長さというか、波の<i>繰り返し</i>部分の<i>時間の</i>長さを指します。 この矩形波を見てください（X軸は時間）。<br><br>
        <div id="xdzs" style="text-align: left">
          <img style="width: 240px; height: 50px" src="img/File_id_d36ccdg_32dh4jjkdf_b" original-src="http://docs.google.com/File?id=d36ccdg_32dh4jjkdf_b" show-src="img/File_id_d36ccdg_32dh4jjkdf_b">
        </div>
        高いところから始まって、2時間単位で高くなり、低くなって2時間単位で低くなる、という繰り返しです。 周期というのは、この繰り返しの波の水平方向の時間長さを言っています。この場合、周期は4時間単位です。 周期が長いほど音は低くなり、逆に周期が短いほど音は高くなります。 この3つの矩形波を見てみましょう。<br><br>周期＝6時間単位<br>
        <div id="o6dq" style="text-align: left">
          <img style="width: 240px; height: 50px" src="img/File_id_d36ccdg_33fm9jm9dg_b" original-src="http://docs.google.com/File?id=d36ccdg_33fm9jm9dg_b" show-src="img/File_id_d36ccdg_33fm9jm9dg_b">
        </div>
        <br>周期＝4時間単位<br>
        <div id="wj8x" style="text-align: left">
          <img style="width: 240px; height: 50px" src="img/File_id_d36ccdg_34gmf46jdj_b" original-src="http://docs.google.com/File?id=d36ccdg_34gmf46jdj_b" show-src="img/File_id_d36ccdg_34gmf46jdj_b">
        </div>
        <br>周期＝1タイムユニット<br>
        <div id="mw1w" style="text-align: left">
          <img style="width: 240px; height: 50px" src="img/File_id_d36ccdg_354r6gfhx5_b" original-src="http://docs.google.com/File?id=d36ccdg_354r6gfhx5_b" show-src="img/File_id_d36ccdg_354r6gfhx5_b">
        </div>
        <br>上の波が最も周期が長く（6単位）、最も低い音になります。 下の波は周期が短く（1単位）、他の2つよりも高い音になります。<br><br>ファミコンの場合、APUのポートに11ビットの周期を書き込みます。 数字が小さいほど周期が短く、高い音になります。 数字が大きい＝周期が長い＝低い音になります。 以下のコードを見て、□1のポートに11ビットの周期を書き込んでみましょう。<br><br><span style="font-family: Courier New"> lda #$C9</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$05</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003 ;period $5C9: 数字が大きい＝周期が長い＝音が低い</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;----</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$09</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003 ;期間 $009：数字が小さい＝期間が短い＝音が非常に高い</span><br><br><b>ピリオド→音符</b><br>では、11ビットのピリオド値がどの音符に対応するかを知るにはどうしたらよいのでしょうか。 魔法のフォーラムはこうです。<br><br>P = C/(F*16) - 1<br><br>P = 周期<br>C = CPUのスピード（単位：Hz <br>F = ノートの周波数（これもHz単位）。<br><br>Cの値はNTSCとPALのマシンで異なるため、NTSC用に作られたゲームがPALのファミコンでおかしな音になったり、その逆が起こったりします。<br><br>音符の周期値を求めるには、音符の周波数を調べて、それを式に差し込まなければなりません。 あるいは、誰かがすでにその作業を終えて、読みやすい表にしてくれていることを祈るしかありません。 幸運にも、Celiusというクールな人がNTSCとPALの両方でそれをやってくれました。 ここにその表があります。<br><br><a href="downloads/missing/NotesTableNTSC.txt" target="_blank" original-href="http://www.freewebs.com/the_bott/NotesTableNTSC.txt">http://www.freewebs.com/the_bott/NotesTableNTSC.txt</a><br>
       <a href="downloads/missing/NotesTablePAL.txt" target="_blank" original-href="http://www.freewebs.com/the_bott/NotesTablePAL.txt">http://www.freewebs.com/the_bott/NotesTablePAL.txt</a><br>
        <br><b><font size="4">ルックアップテーブル</font></b><br>周期値をルックアップテーブルに格納するのは、ごく一般的な方法です。<b>ルックアップテーブルとは</b>、あらかじめ計算されたデータをROMに格納した表です。 解答用紙と同じです。 ルックアップテーブルを使うと、複雑で時間のかかる計算を省くことができます。例えば、Aという値を受け取って3^Aを返すサブルーチンを作りたい場合、力技で書くと次のようになります。<br><br><span style="font-family: Courier New">乗算器 .rs 1</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">Aの値(0-5)を受け取って3^Aを返す。</span><br style="font-family: Courier New"><span style="font-family: Courier New">three_to_the_a:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> BN .NOT_ZERO</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$01 ;3^0は1です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New">.not_zero</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$03</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ループ </span><br style="font-family: Courier New"><span style="font-family: Courier New"> staの乗数</span><br style="font-family: Courier New"><span style="font-family: Courier New"> デ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .done</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ADC乗算器</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc乗算器</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これは動作しますが、あまりきれいではありません。 ルックアップテーブルを使った方法は次のとおりです。<br><br><span style="font-family: Courier New">;あらかじめ計算された答えを持つルックアップテーブル</span><br style="font-family: Courier New"><span style="font-family: Courier New">powers_of_3:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 1, 3, 9, 27, 81, 243</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">three_to_the_a:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda powers_of_3, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>コーディングが簡単で、読みやすく、そして実行速度も速くなります。<br><br><b>NESASM3 Tip#1: ローカルラベル</b><br>上の例で、いくつかのラベルの前にピリオドをつけたことにお気づきでしょうか。NESASM3はこれらをローカルラベルとして扱います。 ラベルにはグローバルとローカルの2種類があります。<b>グローバルラベル</b>はプログラム全体に存在し、一意でなければなりません。<b>ローカルラベルは</b>2つのグローバルラベルの間にのみ存在します。 つまり、ローカルラベルの名前は再利用でき、その範囲内で一意であればいいのです。ローカルラベルを使えば、ループなどのよくあるケースで一意な名前を作る手間が省けます。 私は、サブルーチン内で発生するラベルはすべてローカルラベルを使うことが多いです。 ローカルラベルを作るには、ラベルの前にピリオドを付けます。<br><br><font size="3"><b>ノートルックアップテーブル</b></font><br>Celiusのテーブルをノートルックアップテーブルに変換してみましょう。ピリオド値は11ビットなので、ルックアップテーブルをワードで定義する必要があります。 .wordは.dwと同じであることに注意してください。 以下はNTSC用のnote_tableです。<br><br><span style="font-family: Courier New">注：音楽におけるオクターブは伝統的にAではなくCから始まります。 </span><br style="font-family: Courier New"><span style="font-family: Courier New">音楽におけるオクターブは伝統的にAではなくCから始まります。</span><br style="font-family: Courier New"><span style="font-family: Courier New">note_table:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード07f1、$0780、$0713 ; a1-b1 ($00-$02)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $06AD、$064D、$05F3、$059D、$054D、$0500、$04B8、$0475、$0435、$03F8、$03BF、$0389 ; C2-B2 ($03-$0E)の場合。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $0356, $0326, $02F9, $02CE, $02A6, $027F, $025C, $023A, $021A, $01FB, $01DF, $01C4 ; C3-B3（$0F-$1A）の場合。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $01AB、$0193、$017C、$0167、$0151、$013F、$012D、$011C、$010C、$00FD、$00EF、$00E2 ; C4-B4（$1B-$26）の場合</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード $00D2、$00C9、$00BD、$00B3、$00A9、$009F、$0096、$008E、$0086、$007E、$0077、$0070 ; C5-B5（$27-$32）の場合</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $006A、$0064、$005E、$0059、$0054、$004F、$004B、$0046、$0042、$003F、$003B、$0038 ; C6-B6（$33-$3E)の場合</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $0034、$0031、$002F、$002C、$0029、$0027、$0025、$0023、$0021、$001F、$001D、$001B ; C7-B7（$3F-$4A)の場合。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $001A, $0018, $0017, $0015, $0014, $0013, $0012, $0011, $0010, $000F, $000E, $000D ;C8-B8 ($4B-$56)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード $000C、$000C、$000B、$000A、$000A、$0009、$0008C9-F#9 ($57-$5D) ; C9-F#9 ($57-$5D)</span><br style="font-family: Courier New"><br>最高オクターブでは、いくつかの音が同じ値になっていることに注意してください（たとえば、C9とC#9）。 これは丸めによるものです。 高音になるほど精度が落ち、その結果、多くの最高音は調子が悪くなります。 ですから、歌ではおそらく8と9は使わないでしょう。 しかし、これらの高音は音響効果に使えるので、そのままにしておきます。<br><br>音符のルックアップテーブルができたら、目的の音符をテーブルのインデックスとして使用し、そこからピリオド値を引き出します（このような方法です）。<br><br><span style="font-family: Courier New"> lda #$0C ;テーブルの13番目の項目(A2)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;単語のテーブルにインデックスを付けているので、2倍する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y ;ピリオドの下位バイトを読み取る。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002 ;SQ1_LOに書き込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y ;期間の上位バイトを読み出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003 ;SQ1_HIにライトする。</span><br><br>各音符にどのインデックスを使うかわかりやすくするために、<b>記号の</b>リストを作ります。<br><br><span style="font-family: Courier New">注：音楽におけるオクターブは、伝統的にAではなくCから始まります。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;オクターブ1</span><br style="font-family: Courier New"><span style="font-family: Courier New">A1 = $00 ; "1 "はオクターブ1を意味します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">As1 = $01 ; "s "は "シャープ "を意味します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">Bb1 = $01 ; "b "は "フラット "を意味します。 A# == Bb</span><br style="font-family: Courier New"><span style="font-family: Courier New">B1 = $02</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;オクターブ2</span><br style="font-family: Courier New"><span style="font-family: Courier New">C2 = $03</span><br style="font-family: Courier New"><span style="font-family: Courier New">Cs2 = $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">Db2 = $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">D2 = $05</span><br style="font-family: Courier New"><span style="font-family: Courier New">;...</span><br style="font-family: Courier New"><span style="font-family: Courier New">A2 = $0C</span><br style="font-family: Courier New"><span style="font-family: Courier New">As2 = $0D</span><br style="font-family: Courier New"><span style="font-family: Courier New">Bb2 = $0D</span><br style="font-family: Courier New"><span style="font-family: Courier New">B2 = $0E</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;オクターブ3</span><br style="font-family: Courier New"><span style="font-family: Courier New">C3 = $0F</span><br style="font-family: Courier New"><span style="font-family: Courier New">;... など</span><br><br>これで、実際のインデックス値の代わりに新しいシンボルを使うことができます。<br><br><span style="font-family: Courier New"> lda<b>#A2</b>;A2. #A2 は #$0C に評価されます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;単語のテーブルにインデックスを付けているので、2倍する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y ;ピリオドの下位バイトを読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002 ;SQ1_LOに書き込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y ;期間の上位バイトを読み出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003 ;SQ1_HIにライトする。</span><br><br>また、後で一連の音符を持ちたくなった場合、記号の方が読みやすく、変更もしやすい。<br><br><span style="font-family: Courier New">sound_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C3, E3, G3, B3, C4, E4, G4, B4, C5 ; Cmaj7 (CEGB)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_data_no_symbols:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $0F, $13, $16, $1A, $1B, $1F, $22, $26, $27 ;上と同じだが、読みにくい。Cmaj7 (CEGB)</span><br><br><br><b>ローノート・オン・スクエア（スイープ・ユニット）</b><br>最後に、とても重要なことを述べておきます。 それは、Squareチャンネルのスイープユニットに関係します。 スイープユニットは、ある状況（Periods &gt;= 400、私たちの最低音）では、<i>無効にしていても</i>、Squareチャンネルを沈黙させます。 この問題を解決するには、スイープユニットポートをちょっと見てみる必要があるでしょう。<br><br><span style="font-family: Courier New">sq1_sweep ($4001), sq2_sweep ($4005)</span><br style="font-family: Courier New">
        <br style="font-family: Courier New">
       <span style="font-family: Courier New">76543210</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||+++- シフト</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||||+----- ネゲート</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">||+++----- スイープ単位周期</span><br style="font-family: Courier New">
       <span style="font-family: Courier New">+-------- 有効 (1: 有効、0: 無効)</span><br><br>その仕組みは今さら説明しませんが、低音の不要な消音は、<b>ネゲートフラグを設定</b>することで回避できます。<br><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$08 ;スイープユニットのネゲートフラグを設定する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4001 ;スクエア2の場合は4005ドル。</span><br><br>もし本当に理由を知りたければ、blarggの<a href="scraper/files/apu_ref.txt" target="_blank" original-href="http://www.slack.net/%7Eant/nes-emu/apu_ref.txt">NES APU Sound Hardware Technical Referenceの</a>Sweep Unitのセクションをチェックしてみてください。<br><br><b>PALについてはどうでしょうか？</b><br>このチュートリアルでは、わかりやすくするためにNTSCの数字を使います。 サウンドエンジンが完成したら、PALのサポートを追加するチュートリアルを作成しようと思っています。<br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/periods.zip" target="_blank" original-href="http://tummaigames.com/periods.zip">periods.zip</a>のサンプルファイルをダウンロードし、解凍します。 periods.asm, periods.chr, note_table.i, periods.bat がすべて NESASM3 と同じフォルダにあることを確認し、 periods.bat をダブルクリックします。これでNESASM3が実行され、periods.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。 Dパッドでノートテーブルから任意の音を選択し、Square 1チャンネルで演奏します。 コントロールは以下の通りです。<br><br><b>Up</b>- 選択した音符を演奏する<br><b>Down</b>- ノートを停止します。<br><b>左</b>- 選択範囲を1音下へ移動<br><b>右</b>- 選択範囲を1音分上に移動<br><br><b>宿題</b>です。periods.asmを編集し、Square 2とTriangleチャンネルのサポートを追加します。 ユーザーがチャンネルを選択し、3つのチャンネルすべてで異なる音符を演奏できるようにします。<br><br>宿題<b>その2</b>: Dischのドキュメント<a href="http://nesdevhandbook.googlepages.com/theframe.html" target="_blank" original-href="http://nesdevhandbook.googlepages.com/theframe.html">The Frame and NMIを</a>読んでください。 特に「NMIをフルに活用する」のセクションに注目してください。 私たちはこのスタイルのNMIハンドラをサウンドエンジンで使うつもりです。 実際、periods.asmではすでにこのスタイルを使っています。<br><br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024">サウンド</a>エンジンを起動する。<br><br><br><br><br><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-3__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22776" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-4">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。パート4：サウンドエンジンのスケルトン</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>:<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22776" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=22776">ピリオド、ルックアップテーブル</a><br><br><b>今週は</b>サウンドエンジンの基本。 サウンドエンジンを動かすためのフレームワークをセットアップします。<br><br><b><font size="4">サウンドエンジン</font></b><br><br>音符を演奏させる方法がわかったので、サウンドエンジンについて考え始めましょう。 サウンドエンジンに何をさせたいか、メインプログラムはサウンドエンジンとどのように相互作用するか、などです。<br><br>サウンドエンジンはメインプログラムのコードに干渉してはいけませんし、その逆も同様です。 両者を混在させると、コードが読みづらくなり、変数の衝突の危険性が高まり、見つけにくいバグに直面する可能性が高くなります。また、分離することで、コードの再利用が容易になります。 サウンドエンジンが内部のルーチンと変数にしかアクセスしない場合、あるゲームからそれを取り出して別のゲームに接続することがより容易になります。<br><br>もちろん、メインプログラムとサウンドエンジンの間には、何らかのコミュニケーションが必要です。 メインプログラムは、サウンドエンジンに次のようなことを指示することができなければなりません。「しかし、メインプログラムがサウンドエンジンの仕事に立ち入ることはありません。 メインプログラムはコマンドを発行するだけで、あとはサウンドエンジンが独自に処理します。<br><br>そのために、メインプログラムがサウンドエンジンを呼び出して命令するための小さなサブルーチン群を作ります。 このサブルーチンを<b>「入口</b>」と呼ぶことにします。 サウンドエンジンへの入口はできるだけ少なくしたいのです。 サウンドエンジン自身は内部でいくつかのサブルーチンを持っていて、メインプログラムは入口だけを使うことになります。<br><br><b>エントランス</b><br>メインプログラムがサウンドエンジンに何をさせるかを考える必要があります。 以下に、サウンドエンジンに必要と思われる入り口のリストを示します。<br><br>-サウンドエンジンの初期化 (sound_init)<br>-新しい曲やFXをロードする (sound_load)<br>-音楽/FXのフレームを再生する (sound_play_frame)<br>-サウンドエンジンの無効化(sound_disable)<br><br>括弧内の名前は、コード上でサブルーチンと呼ぶことにします。 読みやすくするためにsound_を前置しました。 一見してサウンドルーチンであることが分かります。 コマンドの実行内容は以下のとおりです。<br><br><b>sound_init</b>はチャンネルを有効にし、それらを消します。 また、サウンドエンジンの変数を初期化します。<br><br><b>sound_loadは</b>曲/sfxの番号を入力とし、その曲番号から曲のヘッダーへのポインターのテーブルをインデックスし、適切なヘッダーを読み込んでサウンドエンジン変数をセットアップします。 意味がわからなくても心配ありません。 この内容については来週に説明します。<br><br><b>sound_play_frame</b>はサウンドエンジンを1フレーム進めます。 ノートタイマーを動かし、（必要なら）データストリームから読み込み、サウンド変数を更新し、APUポートに書き込みを行います。 この内容も次週にカバーする予定です。<br><b><br>
         </b><b>sound_disableは</b>、$4015を介してチャンネルを無効化し、無効化フラグ変数を設定します。<br><br>sound_initとsound_disableの2つのサブルーチンは、すでに十分な知識があります。 今すぐ書きましょう。 他のエントランスサブルーチンについても、スケルトンコードを書きます。 その前に、いくつか触れておくことがあります。<br><br><b>RAM</b><br>サウンドエンジンは多くのRAMを必要とします。 大きなサウンドエンジンはRAMの1ページを占有することさえあります。 このチュートリアルでは、サウンドエンジンの変数はすべてRAMの$300ページに置くことにします。 この数字には何のマジックもありません。000はゼロページRAM、100はスタックです。 Nerdy Nightsシリーズを完成させた方は、200がスプライトOAMになります。 つまり、300がその次です。<br><br><b>ROM</b><br>サウンドエンジン自体は、コード用に多くのROMスペースを必要としませんが、音楽をたくさん聴く場合は、曲のデータが多くのスペースを占めるかもしれません。 このため、ヘッダーを変更して、16K PRG-ROMバンクを2つ与えるようにします。<br><br style="font-family: Courier New"><span style="font-family: Courier New">.inesprg 2 ;2x 16kb PRGコード</span><br><br>これで、万が一に備えて、2倍のROMスペースが確保できました。 ちなみに、これはマッパーを使わずに持てる最大限のROM量です。<br><br><b>ノイズチャンネル</b><br>ノイズチャンネルについては、まだ意図的に説明していません。 しかし、イニシャルコードでサイレンスにしたいので、先にそれを教えます。 ノイズチャンネルのボリュームは、ポート$400Cで制御します。これは、デューティーサイクルの制御がない以外は、スクエアチャンネルに対する$4000/$4004と同じように動作します。<br><br><span style="font-family: Courier New">ノイズチャンネル ($400C)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ||++++- ボリューム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> |+----- Saw Envelope Disable (0: 音量に内部カウンタを使用; 1: 音量にボリュームを使用)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> +------ 長さカウンタ無効 (0: 長さカウンタを使用; 1: 長さカウンタを無効)</span><br><br>四角形と同様に、両方の無効化フラグを設定し、ボリュームを0に設定することで、ノイズチャンネルを消します。<br><br><b><font size="3">スケルトン・サウンド・エンジン</font></b><br>サウンドエンジンの入り口のサブルーチンを書きましょう。 このコードのほとんどは、このシリーズの最初の3つのチュートリアルを完了した方には、とても馴染みのあるものでしょう。<br><br><span style="font-family: Courier New">.rsset $0300 ;サウンドエンジンの変数は、RAMの$0300のページに置かれます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_disable_flag .rs 1 ;サウンドエンジンが無効になっているかどうかを追跡するフラグ変数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 設定されている場合、sound_play_frameは何もせずに戻る�</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.bank 0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.org $8000 ;2つの16K PRGバンクがあるので、サウンドエンジンは$8000から始まる最初のバンクに置くことにします。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">sound_init:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$0F</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015 ;スクエア1、スクエア2、トライアングル、ノイズのチャンネルを有効にする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000 ;矩形1の音量を0に設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4004 ;矩形2の音量を0に設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400C ;Noiseの音量を0に設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008 ;トライアングルの無音化</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_disable_flag ;無効化フラグのクリア</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;後で、他に初期化したい変数があれば、ここで初期化します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_disable:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015 ;全チャンネルを無効にする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_disable_flag ;無効化フラグの設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">sound_load:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;まだ何もない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;無効化フラグが設定されている場合、フレームを進めない</span><br style="font-family: Courier New"><span style="font-family: Courier New">;ここではまだ何もしない</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><br><br><b>サウンドエンジンの駆動</b><br>サウンドエンジンを動かすためのフレームワークができました。 メインプログラムはサウンドエンジンに命令を出すためにサブルーチンを呼び出すことができます。 これらのほとんどはまだ何もしませんが、メインプログラムに統合することができます。 まず、リセットコードのどこかで sound_init を呼び出したいと思います。<br><br><span style="font-family: Courier New">RESET</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sei</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cld</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$FF</span><br style="font-family: Courier New"><span style="font-family: Courier New"> txs</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;... メモリクリアなど</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr sound_init</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;... リセットに関連するもの</span><br><br>次に、サウンドエンジンを動かすものが必要です。 音楽はタイムベースです。 どんな音楽でも、テンポが一定なら、4分音符は他の4分音符と正確に同じ長さでなければなりません。 全音符は4分音符と正確に同じ長さでなければならないのです。サウンドエンジンが音楽を奏でるには、時間軸が必要です。 サウンドエンジンを1フレームずつ進めるサブルーチン、sound_play_frameがあります。 このサブルーチンが一定の時間間隔で繰り返し呼び出されるようにする必要があります。<br><br>NMIを有効にすると、Vblankの開始時にNMIがトリガーされます。 VblankはPPUに書き込む唯一の安全な時間なので、NMIは通常描画コードでいっぱいになります。 サウンドコードを実行して貴重なVblank時間を無駄にしたくありませんが、描画終了後はどうでしょう。sound_play_frameは1フレームに1回呼ばれるので、PPUの足を引っ張ることはありません。 また、sound_play_frameはPPUレジスタに書き込まないので、サウンドコードがvblankからこぼれても問題ありません。<br><br>サウンドエンジンを駆動するためのNMIを設定しましょう。<br><br><span style="font-family: Courier New">NMIです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> PHA ;レジスタの保存</span><br style="font-family: Courier New"><span style="font-family: Courier New"> txa</span><br style="font-family: Courier New"><span style="font-family: Courier New"> pha</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tya</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ファ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> スプライトDMAを行う</span><br style="font-family: Courier New"><span style="font-family: Courier New">;必要ならパレットを更新する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> スクリーンに描画する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> スクロールを設定する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr sound_play_frame ;描画が終わったらサウンドエンジンを実行する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;これでサウンドエンジンは1フレームに1回実行されることになる�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sleeping ;先週のDischのドキュメントを読んで宿題をやりましたか？</span><br style="font-family: Courier New"><span style="font-family: Courier New">;<a href="http://nesdevhandbook.googlepages.com/theframe.html" target="_blank" original-href="http://nesdevhandbook.googlepages.com/theframe.html">http://nesdevhandbook.googlepages...</a></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> pla ;レジスタの復元</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> プラ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 税金</span><br style="font-family: Courier New"><span style="font-family: Courier New"> プラ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rti</span><br><b><br>
          .include</b><br>サウンドエンジンとメインプログラムをさらに分離するために、サウンドエンジンのコード をすべて別のファイルに保存することができます。NESASM3ではソースファイルをメイン プログラムにコピーするために.includeという命令があります。 先週は実際にこの命令を使って、周期参照テーブルを含む note_table.i ファイルをインクルードしました。<br><br>.includeを使ってソースファイルをコードにコピーするのは、.incbinを使って.chrファイルをインポートするのと非常に似ています。 サウンドエンジンのコードがsound_engine.asmというファイルに保存されていると仮定して、次のコードをメインプログラムに追加してみます。<br><br><span style="font-family: Courier New">.include "sound_engine.asm"</span><br><br>note_table.iを引き続きインクルードしますが、これはサウンドエンジンの一部なので、sound_engine.asmファイルに.includeディレクティブを貼り付けます。<br><br>インクルードを多用するのは悪いことではありません。 ジョイパッドのルーチンを取り出して自分のファイルに入れることもできます。 ゲームステートコードやPPUルーチンなど、思いつくものは何でも別のファイルにすることができます。 このようにコードを分割しておけば、プログラムが大きく複雑になったときに探しやすくなります。 また、古いルーチンを新しいプログラムに組み込むことも容易になります。<br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/skeleton.zip" target="_blank" original-href="http://tummaigames.com/skeleton.zip">skeleton.zip</a>のサンプルファイルをダウンロードして解凍します。 skeleton.asm, sound_engine.asm, skeleton.chr, note_table.i, sound_data.i および skeleton.bat がすべて NESASM3 と同じフォルダにあることを確認し、 skeleton.bat をダブルクリックしてください。これでNESASM3が実行され、skeleton.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>Sound_load と Sound_play_frame をハードコードして、Square 1 チャンネルで小さなメロディーを演奏します。 これは単純なフレームカウンタを使用して音符の速度を制御します。音楽のデータは sound_data.i ファイルにあります。 サウンドエンジンと対話するにはコントローラを使ってください。 コントロールは次のとおりです。<br><br><span style="font-weight: bold">A</span>: サウンドを最初から再生する (sound_load)<br><span style="font-weight: bold">B</span>: サウンドエンジンの初期化(sound_init)<br><span style="font-weight: bold">Start</span>: サウンドエンジンを無効にする(sound_disable)<br><br>sound_engine.asm を編集して、sound_play_frame が読み込むデータストリームを変更してみてください。 sound_data.i には、さまざまなデータストリームが用意されています。 先週作ったノート記号を使って、データストリームを $FF で終了してください。<br><br><b>宿題</b>：メインプログラムが使用するサウンドエンジン入り口のサブルーチンを2つ書いてください。<br>1. sound_pause: サウンドの再生を一時停止しますが、データストリームの現在の位置を保持します。<br>2. sound_unpause: サウンドが現在一時停止している場合、保存された位置から再生を再開します。<br>次に、ユーザーが音楽の一時停止/一時停止を行えるように、handle_joypadを修正します。<br><br><b>宿題その2</b>：もしDischの<a href="http://nesdevhandbook.googlepages.com/theframe.html" target="_blank" original-href="http://nesdevhandbook.googlepages.com/theframe.html">The Frames and NMI</a>ドキュメントで提示されたアイデアがまだ頭の中で曖昧な場合は、もう一度読んでください。<img src="img/blank.gif" border="0" style="display: none" original-src="i/expressions/face-icon-small-smile.gif" show-src="img/blank.gif"><br><br><b>追加クレジット</b>：私の描画バッファの動作を理解できるかどうか確認してください。 Dischのドキュメントを参考にしてください。明らかな理由により、このサウンドチュートリアルでは描画バッファを取り上げませんが、その使用方法を学ぶことは間違いなくあなたの時間の価値があることでしょう。<br><br><b>次週</b>：<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452">サウンドデータ、ポインタテーブル、ヘッダ</a><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-4__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-5">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">
          オタクな夜のサウンド。パート5：サウンドデータ、ポインタテーブル、ヘッダ        </h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23024">サウンドエンジンの基礎、スケルトン・サウンドエンジン</a><br><br><b>今週は</b>サウンドデータ、ポインタテーブル、ヘッダ<br><br><font size="4"><b>サウンドデータの設計</b></font><br><br>サウンドエンジンの骨格ができたので、次は肉付けです。 曲を再生するには、曲をロードする必要があります。 曲をロードするには、曲データが必要です。 次のステップは、サウンドデータの外観を決めることです。 データフォーマットを設計し、テストデータを作成して、データを読み込んで再生するエンジンを構築する必要があります。<br><br><b>データフォーマット</b><br>サウンドデータの形式は、どのように設計すればよいのでしょうか。 まず、私たちが何を再生しようとしているのかを見てみましょう。 私たちのサウンドエンジンには、2種類の基本的なサウンドデータがあります。<br><br>1.音楽<br>2.サウンドエフェクト(SFX)<br><br><i>音楽は</i>バックグラウンドで再生され、最初の4チャンネルを使い、テンポがあり、 通常は何度も繰り返し再生されます。<br><br><i>サウンド</i>エフェクトは、ゲームイベント（ボールがパドルに当たるなど）がトリガーとなり、無限にループするわけではありません。<br><br>効果音は、今何が起こっているかをプレイヤーに伝える役割を担っているので、音楽よりも優先されます。 スクエア2チャンネルで音楽が流れていて、同じスクエア2チャンネルを効果音が使っている場合、音楽の代わりに効果音が再生されます。<br><br>例えば、ゼルダのようなゲームでは、プレイヤーが剣を振る音よりも、ダメージを受ける音が優先されます。 前者はプレイヤーに重要な情報を伝え、後者は単なる効果音です。<br><br><b>ストリーム</b><br>前述したように、効果音は音楽とチャンネルを共有する必要があります。 通常、音楽はすべてのチャンネルを同時に使うので、これは避けられません。 つまり、効果音が再生されると、音楽から1チャンネル（またはそれ以上）離さなければならないのです。効果音を再生するために、あるチャンネルで音楽を止めた場合、効果音が終わった後、そのチャンネルの音楽をどこで再開すればいいのか、どうやって知ることができるのでしょうか。<br><br>答えは、共有チャンネルの音楽を止めるのではなく、他の音楽チャンネルと同じように1フレームずつ進めて、効果音の再生中にそのデータをAPUポートに書き込まないようにすればよいのです。<br><br>データ<b>ストリームとは</b>、サウンドエンジンが読み込んでAPUへの書き込みに変換するROMに格納されたバイト列のことです。 各ストリームは1つのチャンネルに対応しています。音楽には4つのデータストリームがあり、各チャンネルに1つずつあります。 効果音には2つのストリームがあり、SFX自身が使用するチャンネルを選択します。 つまり、同時に実行できるストリームは合計6つです。 以下のように番号を振っていきます。<br><br><span style="font-family: Courier New">MUSIC_SQ1 = $00 ;これらは、ストリーム番号の定数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">MUSIC_SQ2 = $01 ;ストリーム番号は、ストリーム変数のインデックスに使用されます(下記参照)</span><br style="font-family: Courier New"><span style="font-family: Courier New">music_tri = $02</span><br style="font-family: Courier New"><span style="font-family: Courier New">music_noi = $03</span><br style="font-family: Courier New"><span style="font-family: Courier New">SFX_1 = $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">SFX_2 = $05</span><br><br><br>各ストリームは、RAM上に独自の変数を必要とします。 これを整理する簡単な方法は、ブロック単位でRAM領域を確保し、インデックスとしてストリーム番号を使用することです。 <br><br><span style="font-family: Courier New">各ストリームに1つずつ、合計6バイトを確保します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_curr_sound .rs 6 ;このストリームは現在どの曲/sfx # を再生しているのか? </span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_channel .rs 6 ;どのチャンネルで再生されているのか？</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_vol_duty .rs 6 ;このストリームのボリューム/デューティ設定</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_note_LO .rs 6 ;現在再生中のストリームの音符の周期の下位8ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_note_HI .rs 6 ;音符の周期の上位3ビット。</span><br style="font-family: Courier New"><span style="font-family: Courier New">その他</span><br><br>ここでは、各変数のために6バイトを確保している。 各ストリームは、例えば、独自のバイトを取得する。<br>stream_vol_duty+0: MUSIC_SQ1の音量/デューティ設定<br>stream_vol_duty+1: MUSIC_SQ2の音量/デューティ設定<br>stream_vol_duty+2: MUSIC_TRIのオン/オフ設定<br>stream_vol_duty+3: MUSIC_NOIのボリューム<br>stream_vol_duty+4: SFX_1 の音量/デューティ<br>stream_vol_duty+5: SFX_2 の音量/デューティ<br><br>sound_play_frame のコードでは、ストリーム番号をインデックスとして、すべてのストリームをループしています。<br><br><span style="font-family: Courier New"> ldx #$00 ;ストリーム0からスタート (MUSIC_SQ1)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop: ;必要ならROMのデータストリームから読み込む</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop: ;必要ならROMのデータストリームから読み込む ;読み込んだ内容に基づいてストリーム変数を更新する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_vol_duty, x ;xの値は、どのストリームで作業しているのかを決定する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;ボリュームで何かをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 音符の周期を扱う</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> 他の変数でもっといろいろなことをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx ;次のストリーム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06 ;6つ全てのストリームをループする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .ループ</span><br><br>音楽ストリームは常に動作しており、APUポートにフレームごとにデータを更新します。 効果音の再生が始まると、SFXストリームの一方または両方が動作し始めます。 このループはSFXストリームを最後に処理するので、APUへの書き込みは最後になり、共有チャンネルの音楽ストリームを上書きします。チャンネルの競合は、ループの順序によって自動的に対処されます!<br><br><font size="4"><b>音楽</b></font><br>ストリームデータがどのようにRAMに保存されるかは分かりましたが、まだ多くの未解決の問題があります。 曲をどのようにロードするのか？ ROMのどこにデータストリームがあるのか？ データストリームからどのように読み出すのか？ ストリームから読み出したものをどのように解釈するのか？<br><br>そこで、まず音楽データから考えてみましょう。 ファミコンの音楽データの多くは、次の3つのタイプに分類されます。<br><br>1.<b>Note</b>- どの音で演奏するか。A3、G#5、C2、など。<br>2.2.<b>音符の長さ</b>：8分音符、4分音符、全音符、など。<br>3.<b>オペコード</b>：ループ、音量調整、四角のデューティーサイクル変更など、特定のタスクを実行するようエンジンに指示する。<br>*3.5.<b>引数</b>- いくつかのオペコードは、引数を入力として受け取ります（例：何回ループさせるか、どこにループさせるか）。<br><br><b>範囲</b><br>サウンドエンジンがこれら3種類のデータを簡単に区別できるように、データフォーマットを設計する必要があります。 そのために、範囲を指定します。 例えば、$00〜$7Fのバイト値は音符を表し、$80〜$9Fは音符の長さ、$A0〜$FFはオペコードを表すとします。重要なのは、あるバイトが音符、音符の長さ、オペコードであるかどうかを判断するためのテスト範囲を設定することです。 エンジンコードでは、次のようなコードになります。<br><br><span style="font-family: Courier New">fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_pointer], y ;データストリームからバイトを読む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードである</span><br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length: ;do Note Length stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;ノートに関すること</span><br><br>このコードはサウンドデータから1バイトを読み込み、そのバイトがどの範囲に入るかをテストします。 可能な範囲ごとにコードの別のセクションにジャンプします。 サウンドデータ、マップデータ、テキストデータなど、ほとんどのデータフォーマットがこのように範囲分けされます。<br><br><b>BPLとBMI</b><br>BEQ、BNE、BCS、BCCに続く最も一般的な分岐命令で、範囲判定によく使用されます。<br><br><b>BPLは</b>ネガティブ（N）フラグをテストし、クリアされていれば分岐します。 BPLはBranch if PLusと考えてください。 最後に実行した命令の結果が#$80以下であれば、Nフラグはクリアされます（つまり、<i>ビット7がクリアされている</i>）。<br><br><span style="font-family: Courier New"> lda #%01101011</span><br style="font-family: Courier New"><span style="font-family: Courier New">; |</span><br style="font-family: Courier New"><span style="font-family: Courier New">; +-------- ビット7がクリアされ、Nフラグがクリアされます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .somewhere ;Nフラグがクリアされたので、分岐します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10010101</span><br style="font-family: Courier New"><span style="font-family: Courier New">; |</span><br style="font-family: Courier New"><span style="font-family: Courier New">; +-------- bit7がセットされているため、Nフラグがセットされます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .somewhere ;Nフラグがセットされているので、分岐しない。</span><br><br><b>BMIは</b>その逆で、Nフラグをテストしてセットされていれば分岐します。 BMIはBranch if MInusと考えてください。 最後に実行した命令の結果が#$80以上（つまり<i>bit7がセットされて</i>いる）であればNフラグがセットされるのです。<br><br><span style="font-family: Courier New"> lda #%01101011</span><br style="font-family: Courier New"><span style="font-family: Courier New">; |</span><br style="font-family: Courier New"><span style="font-family: Courier New">; +-------- bit7がクリアされ、Nフラグがクリアされます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bmi .somewhere ;Nフラグがクリアされているので、分岐しません。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #%10010101</span><br style="font-family: Courier New"><span style="font-family: Courier New">; |</span><br style="font-family: Courier New"><span style="font-family: Courier New">; +-------- bit7 がセットされているため、N フラグがセットされる。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bmi .somewhere ;Nフラグがセットされているので、これはラベル.somewhereに分岐します。</span><br><br>上の範囲テストのコードでは、BPLを使って、バイトがNoteの範囲（00-7F）に入るかどうかをチェックしました。 戻って、チェックしてみてください。<br><font size="4"><br>
         <b>曲のヘッダー</b></font><br>ファミコンの音楽は通常、四角1、四角2、三角、ノイズの4つのパートで構成されています。 曲を演奏したいときは、メインプログラムでサウンドエンジンに演奏したい曲を伝えるコマンドを発行します。 以下のような感じでしょうか。<br><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$02</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr sound_load ;曲2をロードする。</span><br><br>サウンドエンジンのサブルーチンは、この "2 "という数字を、スクエア1、スクエア2、トライアングル、ノイズのパートからなる1つの曲に変換しなければなりません。 この小さな数字がどうやって4つのデータストリームになるのでしょうか。 この数字は、ソングヘッダーへのポインターのテーブルのインデックスです。ソングヘッダー自体は、個々のチャンネルのデータストリームへのポインターが含まれています。<br><br><font size="4"><b>ポインター・テーブル</b></font><br>ポインターテーブルとは、特殊なルックアップテーブルの一種です。 ただ、通常の数値データではなく、<b>アドレスを</b>保持します。 このアドレスがデータの開始点を「指す」のです。 NESのアドレスは16ビット（$0000-$FFFF）なので、ポインターテーブルは常にワードのテーブルです。 例を見てみましょう。<br><br><span style="font-family: Courier New">pointer_table:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $8000、$ABCD、$CC10、$DF1B</span><br><br>ポインタテーブルの長さは4エントリで、各エントリは16ビットアドレスです。 おそらく、これらの4つのアドレスには、プログラム中に読みたいデータがあるはずです。 このデータを読むには、ポインタテーブルをインデックスし、アドレスを取得してゼロページポインタ変数に格納し、間接モードで読み取る必要があります。<br><br><span style="font-family: Courier New">.rsset $0000</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">ptr1 .rs 2 ;2バイトのポインタ変数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 1バイト目はアドレスのLOバイトを格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 2バイト目はアドレスの上位バイトを格納する。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.org $E000 ;ROMのどこか</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$02 ;ポインタテーブルの3番目のエントリ($CC10)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;ワードのテーブルにインデックスを付けるので2倍する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda pointer_table, y ;#$10 - リトルエンディアンのため、ワードはLOバイトから保存されます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta ptr1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda pointer_table+1, y ;#$CC</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta ptr1+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> これでptr1にポインタが設定されました。 これはアドレス$CC10を「指して」います。 そこからデータを読み込んでみましょう。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [ptr1], y ;間接モード。$CC10にあるバイトを読む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta some_variable</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [ptr1], y ;$CC11のバイトを読み出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta some_other_variable</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New">;... など</span><br><br>このコードは、ポインタテーブルからインデックスを受け取ってアドレスを読み取ります。 このアドレスをptr1という変数に格納します（LOバイトが最初）。 そして、このアドレスから間接モードで読み取ります。間接モードは、ポインタ変数の周りに[]を付けることで指定します。 この命令を見てください。<br><br><span style="font-family: Courier New"> LDA [PTR1], Y</span><br style="font-family: Courier New"><br>これは、「ptr1が指しているアドレスを見つけて、そのアドレスにYを足して、そのアドレスの値をAにロードしなさい」という意味です。<br><br>これは非常に汎用性の高いものです。<br><br>もちろん、通常、データがROMのどこにあるかはわかりません。 そこで、アドレスを明示的に宣言する代わりに（$8000, $ABCD, $CC10, など）、ラベルを使用することになります。<br><br><span style="font-family: Courier New">ポインターテーブル:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word data1, data2, data3 ;これらのエントリーは、以下のラベルの16ビットアドレスに評価されます。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">データ1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $FF, $16, $82, $44 ;ランダムなデータ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">data2:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $0E、$EE、$EF、$16、$23</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">データ3:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト $00、$01</span><br><br>
       <b>ソングヘッダーポインタテーブル</b><br>メインプログラムがサウンドエンジンに曲を再生するよう指示すると、ソングナンバーが一緒に送られます。 このソングナンバーは、実はソングヘッダのポインタテーブルへのインデックスなのです。<br><br><span style="font-family: Courier New">song_headers:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song0_header</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song1_header（ワードソング1ヘッダー</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song2_header</span><br style="font-family: Courier New"><span style="font-family: Courier New">;...など</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_load:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;2倍する。ポインタのテーブル(word)にインデックスを付けている</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda song_headers, y ;ポインタテーブルからLOバイトのポインタを読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr ;sound_ptrは0ページポインタ変数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda song_headers+1, y ;HIバイトを読み出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr]、y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta some_variable</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New">;...残りのヘッダーデータを読む</span><br><br><font size="4"><b>ヘッダーデータ</b></font><br>では、曲のヘッダーデータはどのようなものになるのでしょうか。 少なくとも、次のようなことはわかるはずです。<br><br>データストリームの数(曲には通常4つありますが、SFXにはもっと少ないでしょう)<br>どのストリームか(どのストリームインデックスを使うか)<br>これらのストリームが使用するチャンネル<br>これらのストリームを見つける場所（つまり、各ストリームの先頭へのポインタ）。<br>これらのストリームの初期値（例えば、初期ボリュームなど<br><br>サウンドエンジンの機能が増えるにつれて、それらの機能を初期化するためにヘッダーを拡張することがあります。 まずはシンプルに、以下のようなヘッダーを作成します。<br><br><span style="font-family: Courier New">メインヘッダ</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">byte # | それが私たちに伝えること</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00 | ストリームの数</span><br style="font-family: Courier New"><span style="font-family: Courier New">01+｜ ストリームヘッダ（各ストリームに1つずつ配置）</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">ストリームヘッダです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">バイト数｜何がわかるか</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00｜どのストリームか(ストリーム番号)</span><br style="font-family: Courier New"><span style="font-family: Courier New">01｜ステータスバイト(後述)</span><br style="font-family: Courier New"><span style="font-family: Courier New">02｜どのチャンネルか</span><br style="font-family: Courier New"><span style="font-family: Courier New">03｜初期音量（四角の場合はデューティも）</span><br style="font-family: Courier New"><span style="font-family: Courier New">04-05｜データストリームへのポインタ</span><br><br><b>ステータス</b>バイトは、ストリームに関する特別な情報を伝えるビットフラグとなる。 今のところ、ビット0を使用してストリームを有効または無効にマークするだけである。 将来的には、他のビットを使用して、ストリーム優先度などの他の情報を格納することもできるだろう。<br><br style="font-family: Courier New"><b><span style="font-family: Courier New">ストリームステータスバイト</span></b><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New"> |</span><br style="font-family: Courier New"><span style="font-family: Courier New"> +- 有効 (0: ストリームが無効、1: 有効)</span><br style="font-family: Courier New"><br><br>
       <b>ヘッダの例</b><br>以下にヘッダーのサンプルを示す。<br><br><span style="font-family: Courier New">SQUARE_1 = $00 ;チャンネル定数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">SQUARE_2 = $01</span><br style="font-family: Courier New"><span style="font-family: Courier New">TRIANGLE = $02</span><br style="font-family: Courier New"><span style="font-family: Courier New">NOISE = $03</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">MUSIC_SQ1 = $00 ;ストリーム定数</span><br style="font-family: Courier New"><span style="font-family: Courier New">MUSIC_SQ2 = $01 ;ストリーム#はストリーム変数へのインデックスに使用される</span><br style="font-family: Courier New"><span style="font-family: Courier New">music_tri = $02</span><br style="font-family: Courier New"><span style="font-family: Courier New">ミュージック_ノイ = $03</span><br style="font-family: Courier New"><span style="font-family: Courier New">SFX_1 = $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">SFX_2 = $05</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">song0_header:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $04 ;4ストリーム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte MUSIC_SQ1 ;どのストリームか？</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト(ストリーム有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SQUARE_1 ;どのチャンネルか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $BC ;初期音量(C)とデューティ(10)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song0_square1 ;ストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte MUSIC_SQ2 ;どのストリームか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト(ストリーム有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SQUARE_2 ;どのチャンネルか？</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $38 ;初期音量(8)とデューティ(00)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song0_square2 ;ストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte MUSIC_TRI ;どのストリームか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト(ストリーム有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte TRIANGLE ;どのチャンネルか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $81 ;初期音量(オン)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song0_tri ;ストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte MUSIC_NOI ;どのストリームか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $00 ;無効 ロードルーチンで</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $00 ;ストリームを無効にした場合、読み込みルーチンに残りの読み込みをスキップさせます�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> この場合、ロードルーチンは残りの読み込みをスキップします�</span><br style="font-family: Courier New"><span style="font-family: Courier New"><br>
          ストリームヘッダで指定されている実際のデータストリームは以下の通りです。 </span><br style="font-family: Courier New"><span style="font-family: Courier New">song0_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, C5, E5, A5 ;いくつかの音符。 Aマイナー</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">song0_square2:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, A3, A3, E4, A3, A3, E4 ;第2マスで演奏するいくつかの音符。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">song0_tri:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, A3, A3, A3, A3, A3 ;トライアングルデータ</span><br><br><b>サウンドエンジンの変数</b><br>サウンドエンジンは、複数のストリームを同時に走らせます。 4つは音楽用（各音色チャンネルに1つずつ）、2つは効果音用です。 そこで、すべての変数を6つのブロックで宣言します。ヘッダーデータに基づいて、次の変数が必要です。<br><br><span style="font-family: Courier New">stream_curr_sound .rs 6 ;各ストリームに1つずつ、6バイトを確保します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム_ステータス .rs 6</span><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム_チャンネル .rs 6</span><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム_vol_duty .rs 6</span><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム_ptr_LO .rs 6</span><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム_ptr_HI .rs 6</span><br><br><b>サウンドロード</b><br>では、ヘッダを読み込むコードを書いてみましょう。 特にXレジスタに注意してください。 上のヘッダのサンプルを使って、コードをたどることをお勧めします。 以下は、sound_loadルーチンです。<br><br><span style="font-family: Courier New">;-------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">load_sound はサウンドエンジンに曲やサウンドファイルを再生する準備をさせます。</span><br style="font-family: Courier New"><span style="font-family: Courier New">入力。</span><br style="font-family: Courier New"><span style="font-family: Courier New">A: 再生する曲やサウンドの番号。</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_load:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_temp1 ;曲の番号を保存する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;2倍する。ポインタのテーブル（単語）に対してインデックスを作成している</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda song_headers, y ;曲のヘッダへのポインタをセットアップする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda song_headers+1, y ;曲のヘッダへのポインタを設定します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;最初の1バイトを読む。# ストリーム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_temp2 ;temp変数に格納。 これをループカウンタとして使う。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;ストリーム番号</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tax ;ストリーム番号が変数のインデックスになる。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;ステータスバイト(1=有効, 0=無効)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .next_stream ;ステータスバイトが0なら、ストリームは無効なので終了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;チャンネル番号</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;初期デューティとボリューム設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta Stream_vol_duty, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;ストリームデータへのポインタ。 リトルエンディアンのため、下位バイトが先。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [サウンド_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_PTR_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New">.next_stream:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_temp1 ;曲番号</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_curr_sound, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec sound_temp2 ;我々のループカウンター</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これでsound_loadルーチンの準備は完了です。 メインプログラムがこれを呼び出すと、次のようになります。<br><br><span style="font-family: Courier New"> lda #$00 ;曲0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr sound_load</span><br><br>sound_load ルーチンは A レジスタの値を受け取り、それを使ってミュージック RAM に曲を走らせるために必要なものを詰め込みます!<br><br><b>ストリームの読み込み</b><br>ヘッダを読み込んだら、いよいよロック開始です。 アクティブなストリームはすべて、そのデータへのポインタが stream_ptr_LO と stream_ptr_HI 変数に格納されています。 これだけで、データの読み取りを開始することができるのです。<br><br>データストリームからデータを読み出すには、まずストリームポインタをゼロページポインタ変数にコピーします。 次に、間接モードを使ってバイトを読み出し、それが音符か、音長か、オペコードかを範囲テストします。 もし音符なら、note_tableから読み出して11ビット周期をRAMに格納します。 最後に、ストリームポインタを更新してストリームの次のバイトを指し示すのです。<br><br>まず、音符のピリオドのためにいくつかの新しい変数ブロックを宣言する必要があります。<br><br><span style="font-family: Courier New">stream_note_LO .rs 6 ;ピリオドの下位8ビット</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_note_HI .rs 6 ;期間の上位3ビット</span><br style="font-family: Courier New"><br>以下は、se_fetch_byteルーチンです（se_は「サウンドエンジン」の略）。<br><br><span style="font-family: Courier New">;--------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">se_fetch_byte はサウンドデータストリームから1バイトを読み込み、処理する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">; 入力 </span><br style="font-family: Courier New"><span style="font-family: Courier New">X: ストリーム番号</span><br style="font-family: Courier New"><span style="font-family: Courier New">SE_FETCH_BYTE:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x ;ストリームポインタをゼロページポインタ変数にコピーする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x ;ストリームポインタをゼロページポインタ変数にコピーする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;間接モードで1バイト読み出し</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt;#$80, 僕らは音符を持っている</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0 ;else if &lt;#$A0 we have a note length</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else 我々はオペコードを持っている</span><br style="font-family: Courier New"><span style="font-family: Courier New">;まだ何もない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .update_pointer</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;まだ何もない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .update_pointer。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ノート</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl;2倍するのは、ワードのテーブルにインデックスを置くため</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;Yレジスタを保存しておく。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y ;ピリオドの下位8ビットを取り出し、RAMに格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y ;ノートテーブルからピリオドの上位3ビットを引き出す</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta Stream_note_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;Yレジスタをリストアする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> データストリームの次のバイトを指すようにストリームポインタを更新する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.update_pointer:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;データストリームの次のバイトを指すようにインデックスを設定する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tya</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_ptr_LO, x ;LOポインタにYを追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x ;LOポインタにYを追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inc stream_ptr_HI, x ;キャリーがあった場合、HIポインタに1を加える。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>ストリームポインタを更新している部分を見てください。 読み込みがすべて終わると、Yは最後に読み込んだバイトのインデックスを保持します。 次のフレームに備えるために、データストリームの次のバイトを指すようにポインタを更新したいと思います。 これを行うには、Yを増分してポインタに追加します。 しかしここで注意しなければなりません。 現在の位置がこのような場合どうなるでしょうか？<br><br>stream_ptr:$C3FF <br>Y: 1<br><br>この場合、次の位置は$C400になるはずです。 しかし、ADCは8ビットレベルでしか動作しないため、ポインタの下位バイトに1を追加すると、代わりに次のようになります。<br><br>stream_ptr: $C300<br><br>ローバイトのFFは00になりますが、ハイバイトはそのままです。 ハイバイトを手動でインクリメントする必要があります。 しかし、いつインクリメントして、いつ放置するかをどうやって知るのでしょうか？ 幸い、ADCはFF-&gt;00の遷移をするたびにキャリーフラグをセットします。キャリーフラグがセットされていれば、ポインタの上位バイトをインクリメントし、セットされていなければ、インクリメントしない。 上のコードがそうなっています。<br><br><font size="4"><b>音楽を演奏する</b></font><br>ヘッダをロードし、RAMにストリームポインタを設定しました。 ストリームからバイトを読み込んで音符に変換するルーチンを書きました。 さて、sound_play_frameを更新する必要があります。sound_play_frameは6つのストリームをループします。 ステータスバイトをチェックして、それらが有効かどうかを確認します。 有効であれば、ストリームを1フレーム進めます。 以下がそのコードです。<br><br><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;サウンドエンジンが無効の場合、フレームを進めない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> inc sound_frame_counter </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_frame_counter</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$08 ;***この比較値を変更すると、音符の演奏が速くなったり遅くなったりします***。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;8フレームに一度だけアクションを起こします。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$00 ;ストリームのインデックス、MUSIC_SQ1ストリームからスタート</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x ;ビット0をチェックし、ストリームが有効かどうかを確認する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .next_stream ;無効の場合、次のストリームにスキップする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_fetch_byte ;ストリームから読み込んでRAMを更新する。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_set_apu ;現在のストリームのボリューム/デューティ、スイープ、ノート期間をAPUポートに書き込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.next_stream:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06 ;全6ストリームをループする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_frame_counter ;フレームカウンターをリセットして、再び8までカウントを開始できるようにする。 </span><br style="font-family: Courier New"><span style="font-family: Courier New">.完了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br><br>そして、ストリームのデータをAPUのポートに書き込むse_set_apuがこれです。<br><br><span style="font-family: Courier New">se_set_apu:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x ;このストリームはどのチャンネルに書き込むのでしょうか?</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;Yが正しいAPUポートのセットにインデックスされるように4倍する(下記参照)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_vol_duty, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_NOTE_HI, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcs .end ;三角形かノイズの場合、この部分をスキップする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$08 ;else, スイープユニットにネゲートフラグをセットして、四角形で低い音が出せるようにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4001, y</span><br style="font-family: Courier New"><span style="font-family: Courier New">.end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>このようにAPUポートに直接書き込むことは、実は悪いことです。 その理由は、後のレッスンで学びます。<br><br>注意しなければならないのは、APUポートのインデックスをどのように取得するかです。 チャンネルを取得し、それを4倍しています。<br><br><span style="font-family: Courier New">SQUARE_1 = $00 ;これはチャンネル定数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">SQUARE_2 = $01 ;これはチャンネル定数です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">TRIANGLE = $02</span><br style="font-family: Courier New"><span style="font-family: Courier New">NOISE = $03</span><br><br>stream_channel が $00 (SQUARE_1) の場合、4倍して $00 とします。<br>$4000, y = $4000<br>$4001, y = $4001 <br>$4002, y = $4002 <br>$4003, y = $4003<br>stream_channelが$01(SQUARE_2)の場合、4倍して$04となります。<br>$4000, y = $4004<br>$4001, y = $4005<br>$4002, y = $4006<br>$4003, y = $4007 <br>stream_channelが$02(TRIANGLE)の場合、4倍して$08となります。<br>$4000, y = $4008<br>4001, y = $4009 (未使用)<br>4002、y = $400A <br>$4003, y = $400B<br>stream_channelが$03（NOISE）の場合、4倍して$0Cとなります。<br>$4000, y = $400C<br>4001, y = $400D<br>$4002, y = $400E<br>$4003, y = $400F<br>
        <br>
        すべてがきれいに並んでいるのがわかりますか？<br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/headers.zip" target="_blank" original-href="http://tummaigames.com/headers.zip">headers.zipの</a>サンプルファイルをダウンロードして解凍します。 以下のファイルがNESASM3と同じフォルダにあることを確認してください。<br><br>headers.asm<br>sound_engine.asm<br>headers.chr<br>note_table.i<br>song0.i<br>song1.i<br>song2.i<br>曲3.i<br>headers.bat<br><br>headers.batをダブルクリックします。NESASM3が実行され、headers.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラを使って曲を選択し、再生します。 コントロールは以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>次の曲<br><b>左</b>: 前の曲<br><br>headers.asm は、song0 を「再生」して、下を押すと音楽を停止します。 その仕組みは、song0.i を参照してください。<br>Song1はマイナーサードが連なった邪悪なサウンドです。<br>Song2はSq2チャンネルの短い効果音で、SFX_1ストリームを使います。 他の曲と重ねて再生して、音楽からチャンネルを奪っている様子をご覧ください。<br>Song3はシンプルな下降コード進行です。<br><br>独自の曲や効果音を作って、ミックスに追加してみてください。 新しい曲を追加するには、次の手順が必要です。<br><br>1) 曲のヘッダーと曲データを作成する（同梱の曲を参考にしてください）。 データストリームの終端は$FFであることに注意してください。<br>2) ヘッダを sound_engine.asm の下部にある song_headers ポインタテーブル に追加する。<br>3) 定数 NUM_SONGS を更新して、新しい曲数の合計を反映させる (これも sound_engine.asm の一番下にある)<br><br>必要ではありませんが、song0.i, song1.i, song2.i, song3.iで行ったように、曲データを別のファイルに保存することをお勧めします。 この場合、ファイルをincludeするのを忘れないようにしてください。<br><br><b>次週</b>：<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885">タイミング、音符の長さ、バッファリングと休符</a><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-5__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-6">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">
          オタクな夜の音。第6回：テンポ、音符の長さ、バッファリングと休符        </h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=23452">サウンドデータ、ポインタテーブル、ヘッダ</a><br><br><b>今週は</b>テンポ、音符の長さ、バッファリングと休符<br><br><b><font size="4">タイミング</font></b><br><br>先週、サウンドエンジンの大部分を組み上げ、ようやく曲らしいものを演奏できるようになりましたが、タイミングと音符の長さに関しては大きな制約がありました。 サウンドエンジンの6つのストリームすべてで時間を管理するために、1つのフレームカウンターを使用していました。このようなシステムを実際のゲームで使うと、速い曲、遅い曲に変わるたびに効果音が速くなったり遅くなったりします。<br><br>また、フレームカウンターに到達した時はサウンドエンジンを進めて、到達していない時はスキップするというミスもありました。 カウンターが到達してから1～2フレーム後にゲームイベントでサウンドエフェクトがトリガーされたらどうなるでしょう？ 次にカウンターが到達するまでサウンドエフェクトが始まらず、待たされます！遅れが出て、よくありませんね。<br><br>最悪なのは、このフレームカウンタでは、音符の長さを変えることができないことです。 あなたが書くすべての曲が32分音符だけで構成されているのでなければ、これは問題です。 このことから、もっと複雑なタイミングシステムが必要であることがわかります。<br><br><font size="3"><b>テンポ</b></font><br>
        <br>最初の2つの問題は、ユニバーサルカウンターを取り除いて、各ストリームにそれ自身のプライベートカウンターを与えることで解決します。 また、カウント方法も変更します。 フレーム数をカウントして、ある数に達したときにアクションを起こすというこれまでの方法は、非常に限られています。 たとえば、曲があって、フレームカウンターが4フレームごとにアクションを起こしているとしましょう。この場合、曲の音は少し速く聞こえるので、速度を遅くして5フレームごとに更新するようにしました。 しかし、今の曲は遅すぎます。 本当に欲しい速度は4と5の間のどこかですが、フレームカウント法ではそこに到達できません。 代わりに、ティッカーを使うことにします。<br><br><b>ティッカー</b><br>ティッカー方式では、ある数値（<b>テンポ</b>）を取り、それをフレームごとに合計します。 最終的に、その合計はFF-&gt;00から折り返し、その時にキャリーフラグが設定されます（<b>ティック</b>）。 このキャリーフラグのティックが、ストリームを進めるためのシグナルとなります。<br><br>例えば、テンポが40ドルで、トータルが00ドルから始まるとします。 1フレーム後にテンポを足して、00ドル + 40ドル = 40ドル、トータルは40ドルです。 もう1フレーム進みます (2)。 再びテンポを足して、40ドル + 40ドル = 80ドル、トータルは80ドルです。さらに(3)で、$80 + $40 = $C0。 さらに(4)で、$C0 + $40 = $00。 キャリーフラグがセットされています。 ティック！ティックは、このストリームを進めるタイミングを知らせます。 更新が終了したら、次のティックが入るまで、また追加を開始します。<br><br>ご覧のように、テンポ値$40は、4フレームに1回ストリームを進めます。 計算してみると（256 / 5）、テンポ値$33は、およそ5フレームごとにストリームを進めることがわかります。 40が曲にとって速すぎ、$33が遅すぎる場合、$34-$39を試すことができます。 より汎用性があります！なぜこれがうまくいくか、テンポ値が$36の場合にどうなるかを見てみましょう。<br><br><span style="font-family: Courier New">00 + $36 + $36 + $36 + $36 + $36 = $0E (5フレームでティック)</span><br style="font-family: Courier New"><span style="font-family: Courier New">0E + $36 + $36 + $36 + $36 + $36 = $1C（5フレームで刻み目）</span><br style="font-family: Courier New"><span style="font-family: Courier New">1C + $36 + $36 + $36 + $36 = $02 (4フレーム内のティック)</span><br style="font-family: Courier New"><span style="font-family: Courier New">02ドル＋36ドル＋36ドル＋36ドル＋26ドル＝10ドル（5フレームで刻む）</span><br><br>36ドルのテンポでは、ほとんどの場合5フレームごとに刻みが生じますが、4フレームしか生じないこともあります。 このような格差があると、曲の響きが不均一になると思うかもしれませんが、実際には1フレームは約1/60秒しかありません。 我々の耳には、それが気にならず、ちょうど良い響きに聞こえるでしょう。<br><br>以下は、ティッカーを実装するためのコードです。<br><br><span style="font-family: Courier New">stream_tempo .rs 6 ;各フレームのティッカー・トータルに追加される値</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_ticker_total .rs 6 ;私たちの実行中のテロップの合計です。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;無効化フラグが設定されている場合、フレームを進めない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .endloop ;ストリームが無効の場合、このストリームをスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;テンポをティッカー集計に加える。 FF-&gt; 0の遷移があればティックがある。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">lda stream_ticker_total, x</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> clc</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> adc stream_tempo, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> STA STREAM_TICKER_TOTAL, X</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bcc .endloop ;carry clear = no tick. if no tick, we are done with this stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_fetch_byte ;else there is a tick, so do stuff ;もっといろいろなことをする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;もっといろいろやる</span><br style="font-family: Courier New"><span style="font-family: Courier New">.endloopを実行する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .loop</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br><b>初期化</b><br>サウンドエンジンに新しい機能を追加するときはいつでも、次のような質問を自分自身に投げかけたいものです。<br><br>1) その機能は、曲やSFXごとに初期化する必要があるのか？<br>2) もしそうなら、その機能を初期化するために使う値は変数か（つまり、必ずしもすべての曲やSFXで同じでなくてもよい）？<br><br>もし質問1の答えがイエスなら、機能を初期化するためにsound_loadを更新する必要があります。<br>質問2の答えもイエスなら、曲のヘッダーフォーマットにフィールドを追加する必要があります。 初期化に差し込む値は曲ごとに異なるので、曲のヘッダーがそれらの値を提供する必要があります。<br><br>新しいタイミング方式の場合、初期化する必要があるのは、sound_ticker_totalとsound_tempoという2つの変数です。 このうち、sound_tempoだけが可変です。 曲によってテンポは異なりますが、sound_ticker_totalが異なる必要はありません。 そこで、テンポ用の新しいフィールドをソングヘッダーフォーマットに1つ追加する必要があります。<br><br><span style="font-family: Courier New">メインヘッダ。</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">byte #｜ それが教えてくれること</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00｜ストリーム数</span><br style="font-family: Courier New"><span style="font-family: Courier New">01+｜ ストリームヘッダ（各ストリームに1つずつ配置）</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">ストリームヘッダです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">バイト数｜何がわかるか</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00｜どのストリームか(ストリーム番号)</span><br style="font-family: Courier New"><span style="font-family: Courier New">01｜ステータスバイト</span><br style="font-family: Courier New"><span style="font-family: Courier New">02｜どのチャンネルか</span><br style="font-family: Courier New"><span style="font-family: Courier New">03｜初期音量（四角の場合はデューティも）</span><br style="font-family: Courier New"><span style="font-family: Courier New">04-05｜データストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New; background-color: rgb(255, 255, 255); color: rgb(255, 0, 0)">06｜初期テンポ</span><br><br>次に、各ストリームについてこの新しいバイトを読み込んで RAM に保存するように sound_load を編集する必要があります。 また、stream_ticker_total をある固定の開始値、できれば最初のティックが遅れずに起こるように高い値に初期化したいと思います。 最後に、すべての曲を更新してそのヘッダにテンポを含まなければならないでしょう。<br><br><font size="4"><b>音符の長さ</b></font><br><br>曲は、4分音符、8分音符、16分音符など、さまざまな長さの音符で構成されています。 サウンドエンジンは、異なる音の長さを区別する必要があります。 しかし、どのようにするかというと、音価カウンタを使うことになります。<br><br><b>音符の長さのカウンタ</b><br>最も速い音符は32分音符です。 最も速い音符なので、できるだけ小さなカウント値、$01を与えます。 次に速い音符は16分音符です。 音楽では、16分音符は32分音符2つに相当します。 言い換えれば、16分音符は32分音符の2倍の長さがあります。つまり、16分音符は32分音符の2倍の長さです。 次に速い音符は8分音符です。 8分音符は16分音符2つに相当します。 16分音符の2倍の長さなので、カウント値は16分音符の2倍になります：$04 全音符まで行くと、このようにルックアップテーブルを作成することができます。<br><br><span style="font-family: Courier New">note_length_table。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;32分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $02 ;16分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト $04 ;8分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $08 ;4分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $10 ;2分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $20 ;全音符</span><br><br>付点4分音符のような項目は後で追加しますが、今のところこれで十分です。<br><br>異なる音符の長さを演奏するために、各ストリームに音符の長さのカウンターを与えます。<br><br><span style="font-family: Courier New">stream_note_length_counter .rs 6</span><br><br>ある音、たとえば8分音符が演奏されると、そのカウント値が note_length_table から引き出されて、ストリームの音長カウンターに格納されます。 そして、ティックが発生するたびに、カウンターをデクリメントします。音符の長さのカウンタが0になると、音符の演奏が終わり、次の音符を演奏する時間であることを知らせてくれます。 別の言い方をすれば、音符のカウント値は、それが何ティック続くかです。 8分音符は4ティック、4分音符は8ティック、2分音符は16ティックの長さ（10ドル）です。<br><br><b>データ中の音符の長さ</b><br>次に、音符の長さをデータに追加します。 先ほど、$80-$9Fの範囲のバイト値を音符の長さとして指定したことを思い出してください。<br><br style="font-family: Courier New"><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートだ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length: ;音符の長さを指定する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note(ノート)</span><br style="font-family: Courier New"><span style="font-family: Courier New">;音符に関すること</span><br><br>つまり、音符の長さに使える最初のバイト値は$80です。 ルックアップテーブル（上記のnote_length_table）から読み込むので、ルックアップテーブルと同じ順序でバイトを割り当てる必要があります。 <br><br><span style="font-family: Courier New">-----+--------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">バイト｜音符の長さ</span><br style="font-family: Courier New"><span style="font-family: Courier New">-----+--------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">80ドル｜32分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">81ドル｜16分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">82｜8分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">83｜4分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">84ドル｜2分音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">85ドル｜全音符</span><br><br>さて、これらの値をサウンドデータの中で使って、音の長さを表現することができます。<br><br><span style="font-family: Courier New">ソング0、スクエア1チャンネルの音楽データ</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソング0_sq1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $82, C3 ;Cの8分音符を弾く</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $84, D5 ;Dの2分音符を弾く</span><br><br>もちろん、どのバイトがどの音長に対応するかを記憶するのは面倒です。 音データを作るときに簡単にできるように、エイリアスを作っておきましょう。<br><br><span style="font-family: Courier New">音符の長さの定数</span><br style="font-family: Courier New"><span style="font-family: Courier New">30秒 = $80</span><br style="font-family: Courier New"><span style="font-family: Courier New">16分音符 = $81</span><br style="font-family: Courier New"><span style="font-family: Courier New">8分音符 = $82</span><br style="font-family: Courier New"><span style="font-family: Courier New">四分音符 = $83</span><br style="font-family: Courier New"><span style="font-family: Courier New">ハーフ = $84</span><br style="font-family: Courier New"><span style="font-family: Courier New">ホール = $85</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">song0_sq1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth, C3 ;Cの8分音符を演奏する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte half, D5 ;Dの2分音符を演奏する。</span><br><br><b>テーブルからの取り出し</b><br>ルックアップテーブルは0から始まるので、音価（C5, D3, G6）の場合は問題ありません。 しかし、音価データは80-9Fの範囲にあります。つまり、80ドルを00ドルに、81ドルを01ドルに、82ドルを02ドルに変換する方法を考えなければなりません。<br><br>もし「音価から$80を引けばいい」と思ったのなら、自分にクッキーをあげてください。 もし「7ビットを切り落とせばいい」と思ったのなら、自分にクッキーを2枚あげてください。 どちらも有効ですが、後者の方が少し速く、1命令で実行できます。<br><br><span style="font-family: Courier New">se_fetch_byteです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.フェッチ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, it's a Note</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;音符の長さに関することをする</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> and #%01111111 ;ビット7を切り落とす</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sty sound_temp1 ;これから破壊するのでYを保存する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> テイ</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda note_length_table, y ;音長カウント値を取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta stream_note_length_counter, x ;それを音長カウンタに貼り付ける。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> ldy sound_temp1 ;Yを復元する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> iny ;ストリームの次のバイトにインデックスを設定する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jmp .fetch ;別のバイトをフェッチする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note::音符の処理をする</span><br><br>音符の長さを設定した後、.fetchにジャンプアップしていることに注意してください。 これは、データストリームで音符の長さに続く音符を確実に読み取るためです。 もし、音符の長さを設定して単に停止すると、再生時間はわかりますが、どの音を再生すべきかがわからなくなります！これは、音符の長さを設定した後、.fetchにジャンプバックしているためです。<br><br>以下は、ティッカーと音符の長さのカウンターの両方を実装した、最新のsound_play_frameルーチンです。 ティックがあるときだけ音符の長さのカウンターがデクリメントされ、音符の長さのカウンターがゼロになったときだけストリームが進むことに注意してください。<br><br><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;無効化フラグが設定されている場合、フレームを進めない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .endloop ;ストリームが無効の場合、このストリームをスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;テンポをティッカー集計に加える。 FF-&gt; 0の遷移があればティックがある。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ticker_total, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_tempo, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_TICKER_TOTAL, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .endloop ;carry clear = no tick. if no tick, we are done with this stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">dec stream_note_length_counter, x ;else there is a tick. 音符長カウンタをデクリメントする</span>。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .endloop ;カウンタが0でない場合、音符の演奏はまだ終わっていない。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_fetch_byte ;さもなければ、音符の演奏は終了です。 データストリームから読み込む時間です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ボリューム、ノート、スウィープなどをセットする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.endloop:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .loop</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>新しい曲をロードしたら、すぐに演奏を始めたいので、sound_load ルーチンの stream_note_length_counter を初期化します。 sound_play_frame ルーチンはカウンターをデクリメントし、結果がゼロであれば処理をします。 したがって、曲がすぐに始まるように、 stream_note_length_counter を $01 に初期化しなければなりません。<br><br><span style="font-family: Courier New"> sound_load のループの中のどこかです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_length_counter, x</span><br><br>これで、このエンジンは音符の長さをサポートするようになりました。 しかし、まだ改善の余地があります。 8分音符を連続して演奏したい場合はどうでしょうか。 音楽では珍しいことではありません。 この場合、データは次のようになります。<br><br><span style="font-family: Courier New">sound_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth, C5, eighth, E5, eighth, G5, eighth, C6, eighth, E6, eighth, G6, eighth, C7 ;Cmajor</span><br><br>8分音符 "のバイトが多いですね。 8分音符 "を1回だけ記述して、それに続く音はすべて8分音符とした方が良いのではないでしょうか？ このようにです。<br><br><span style="font-family: Courier New">sound_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth, C5, E5, G5, C6, E6, G6, C7 ;Cmajor</span><br><br>これで、6バイトのROMスペースが節約できました。 もし、ゲームに20以上の曲があり、それぞれに4つのデータストリームがあり、同じ長さの音符の文字列がいくつかある可能性を考えると、この種の変更で、何百、何千バイトも節約できるかもしれません。 やってみましょう。<br><br>まず、現在の音符の長さのカウント値をRAMに保存します。 そして、音符の長さのカウンターが0になったら、RAMのカウント値でそれを補充します。<br><br><span style="font-family: Courier New; color: rgb(255, 0, 0)">stream_note_length .rs 6 ;音符の長さのカウント値</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;-------</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_PTR_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.フェッチ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;音符の長さに関することをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> and #%01111111 ;ビット7を切り落とす</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;これから破壊するのでYを保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_length_table, y ;音長カウント値を取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">sta stream_note_length, x ;音符の長さをRAMに保存して、カウンタを再充填</span>するのに使う</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_length_counter, x ;それを音長カウンタに貼り付ける</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;Yを復元する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;ストリームの次のバイトにインデックスを設定する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .fetch ;別のバイトをフェッチする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note::音符の処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;--------</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;無効化フラグが設定されている場合、フレームを進めない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#$01</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .endloop ;ストリームが無効の場合、このストリームをスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;テンポをティッカー集計に加える。 FF-&gt; 0の遷移があればティックがある。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ticker_total, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_tempo, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_TICKER_TOTAL, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .endloop ;carry clear = no tick. if no tick, we are done with this stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec stream_note_length_counter, x ;else there is a tick. 音符長カウンタをデクリメントする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .endloop ;カウンタが0でない場合、音符の再生がまだ終わっていない。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">lda stream_note_length, x ;さもなければ、音符の長さのカウンターを再読み込み</span>する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta stream_note_length_counter, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_fetch_byte ;データストリームから読み込む時間です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;さらにいろいろなことをする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.endloop:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .loop</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>この4行を追加することで、数百バイトのROMスペースを節約できました。 6バイトのRAMとの良いトレードオフです。 さて、データは「文字列」で構成され、音の長さがあり、その後に一連の音符が続きます。<br><br style="font-family: Courier New"><span style="font-family: Courier New">sound_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth, C5, E5, G5, C6, E6, G6, quarter, C6 ;8分音符6つと4分音符1つ</span><br><br>読みやすく、書きやすい。<br><b><br>
          その他の音符の長さ</b><br>さて、すべての設定が終わったので、note_length_tableに他の音符の長さを追加してみましょう。 付点音符は音楽でとてもよく使われます。 付点音符は、その音と次に早い音とが同じ長さになります。 たとえば、付点4分音符は4分音符＋8分音符。 付点8分音符は8分音符＋16分音符。 テーブルにいくつか付点音符をつけて見ましょう。<br><br>note_length_table。<br>.byte $01 ;32分音符<br>.byte $02 ;16分音符<br>.byte $04 ;8分音符<br>.byte $08 ;4分音符<br>.byte $10 ;2分音符<br>.byte $20 ;全音符<br>;---付点音符<br>.byte $03 ;付点16分音符<br>.byte $06 ;付点8分音符<br>.byte $0C ;付点4分音符<br>.byte $18 ;付点2分音符<br>.byte $30 ;付点全音符?<br><br>note_length_tableの実際の順序は重要ではありません。 エイリアスがテーブルと同じ順序であることを確認すればよいのです。<br><br><span style="font-family: Courier New">音符の長さの定数(エイリアス)</span><br style="font-family: Courier New"><span style="font-family: Courier New">30秒 = $80</span><br style="font-family: Courier New"><span style="font-family: Courier New">16分音符 = $81</span><br style="font-family: Courier New"><span style="font-family: Courier New">8分音符 = $82</span><br style="font-family: Courier New"><span style="font-family: Courier New">四分音符 = $83</span><br style="font-family: Courier New"><span style="font-family: Courier New">ハーフ = $84</span><br style="font-family: Courier New"><span style="font-family: Courier New">ホール = $85</span><br style="font-family: Courier New"><span style="font-family: Courier New">d_sixteenth = $86</span><br style="font-family: Courier New"><span style="font-family: Courier New">d_eighth（エイト） = $87</span><br style="font-family: Courier New"><span style="font-family: Courier New">d_quarter（クォーター） = $88</span><br style="font-family: Courier New"><span style="font-family: Courier New">d_half = $89</span><br style="font-family: Courier New"><span style="font-family: Courier New">d_whole = $8A ;16進数で数えることを忘れないでください。</span><br><br>あなたの曲によって、音符の長さのテーブルにどのような項目を追加する必要があるかが決まります。 もしあなたの曲に、3つの全音符をつなげたような本当に長い音があれば、それをテーブル ($60) に追加して、それの別名 (whole_x3) を作ってください。 あなたの曲に、7つの第8音符の長さの音（半音と付点4分音符を合わせたもの）があれば、それをテーブル ($1C) に追加してそれの別名 (seven_eighths) を作ってください。<br><font size="4"><b><br>
            APUへの書き込みをバッファリングする</b></font><br>これまで、APUへの書き込みは一度に1ストリームずつ行ってきました。 2つの異なるストリームがチャンネルを共有すると、どちらも同じAPUポートに書き込まれます。 3つのストリームがチャンネルを共有すると、（SFX_1とSFX_2に2種類のサウンドエフェクトがロードされている場合）同じフレームで3つとも同じAPUポートに書き込まれてしまいます。 これは良くない習慣で、スクエアチャンネルで不要なノイズが生じる可能性もあります。<br><br>そこで、APUのポートに直接書き込むのではなく、RAM上の一時的なポートに書き込むようにします。 ループの順番はそのままにして、SFXストリームが音楽ストリームをオーバーライトするようにします。そして、すべてのストリームが終了したら、一時的なRAMポートの内容をAPUポートに直接、一度にコピーします。 これにより、APUポートへの書き込みは、最大で1フレームに1回だけになります。 これを行うには、まず一時ポート変数用にいくつかのRAMスペースを確保する必要があります。<br><br><span style="font-family: Courier New">ソフト_apu_ports .rs 16</span><br><br>テンポラリポート用に16バイトを確保しました。 それぞれがAPUポートに対応します。<br><br><span style="font-family: Courier New">soft_apu_ports+0 -&gt; $4000 ;スクエア1ポート</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+1 -&gt; $4001</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+2 -&gt; $4002</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフトウエアポート+3 -&gt; $4003</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">soft_apu_ports+4 -&gt; $4004 ;スクエア2ポート</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフトウエアポート+5 -&gt; $4005</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフトウエアポート+6 -&gt; $4006</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+7 -&gt; $4007</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">soft_apu_ports+8 -&gt; $4008 ;トライアングルポート</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+9 -&gt; $4009 (未使用)</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフトウエアポート+10 -&gt; $400A</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+11 -&gt; $400B</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">soft_apu_ports+12 -&gt; $400C ;ノイズポート</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+13 -&gt; $400D (未使用)</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフトウエアポート+14 -&gt; $400E</span><br style="font-family: Courier New"><span style="font-family: Courier New">ソフト_apu_ports+15 -&gt; $400F</span><br><br>まず、sound_play_frame を編集して、se_set_apu の呼び出しをループから外します。 これは、すべてのストリームがループした後に、APU に一度だけ書き込みたいからです。<br><br><span style="font-family: Courier New">;--------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">; sound_play_frame はサウンドエンジンを1フレーム進めます。</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_play_frame:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_disable_flag</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .done ;無効化フラグが設定されている場合、フレームを進めない</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> and #$01 ;ストリームがアクティブかどうかチェックする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .endloop ;チャネルがアクティブでない場合、それをスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;テンポをティッカー合計に加える。 FF-&gt; 0の遷移があれば、ティックがある。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ticker_total, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_tempo, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_TICKER_TOTAL, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .endloop ;carry clear = no tick. if no tick, we are done with this stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec stream_note_length_counter, x ;else there is a tick. 音符長カウンタをデクリメントする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .endloop ;カウンタが0でない場合、音符の再生がまだ終わっていない。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_length, x ;さもなければ、音符の長さのカウンターを再読み込みする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_length_counter, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_fetch_byte</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">;snip</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.endloop:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inx</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpx #$06</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .loop</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jsr se_set_apu</span></span><br style="font-family: Courier New"><span style="font-family: Courier New">.done。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>次に、一時的なAPUポートを本当のAPUポートにコピーするために、se_set_apuを修正します。<br><br><span style="font-family: Courier New">se_set_apu:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$0F</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpy #$09</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .skip ;$4009は未使用です。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cpy #$0D</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .skip ;$400D is unused</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000, y</span><br style="font-family: Courier New"><span style="font-family: Courier New">.skip</span><br style="font-family: Courier New"><span style="font-family: Courier New"> デェ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .loop ;Yが$00 -&gt; $FFになった時点でループを止める</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>次に、一時的なAPUポートにストリームのデータを入れるサブルーチンを書かなければなりません。 この部分は、サウンドエンジンにもっと機能を追加するとより複雑になりますが、今はとてもシンプルです。<br><br><span style="font-family: Courier New">se_set_temp_ports:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_vol_duty, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports, y ;vol</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$08</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+1, y ;スイープ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+2, y ;周期LO</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+3, y ;周期 HI</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>se_set_temp_ports の呼び出しは se_fetch_byte の呼び出しの後に行います。これは、ループから切り離す前の古い se_set_apu 呼び出しの場所です。 sweep を書き込む前にチャンネルをチェックする必要がないことに注意してください。 se_set_apu がこの部分を処理してくれます。 RAM にこれらの値を書き込むことに問題はないので、コードを簡単にするためにここで分岐するのを避けようと思います。<br><br><b>パチパチ音</b><br>Squareチャンネルの4番ポート($4003/$4007)に書き込むと、シーケンサーがリセットされる副作用があります。 ここに頻繁に書き込むと、Squareから嫌なパチパチ音がします。 これは良くないことです。<br><br>se_set_apuは$4003と$4007に書き込むので、1フレームに1回書き込まれることになります。 これでは頻度が高すぎます。 この書き込みを減らす方法を考えなければなりません。 このフレームに書き込みたい値が、前のフレームに書き込んだ値と同じなら、書き込みをスキップするようにしましょう。<br><br>まず、ポートに最後に書き込まれた値を記録する必要があります。 そのためには、いくつかの新しい変数が必要です。<br><br><span style="font-family: Courier New">sound_sq1_old .rs 1 ;最後に$4003に書き込まれた値です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_sq2_old .rs 1 ;最後に$4007に書き込まれた値</span><br><br>これらのポートに書き込むたびに、対応するsound_port4_old変数にも値を書き込みます。 この値を保存しておけば、次のフレームで比較することができます。 これを実装するために、se_set_apuのループをアンロールする必要があります。<br><br><span style="font-family: Courier New">se_set_apu:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4001</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+2</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+3</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_sq1_old ;先ほど$4003に書き込んだ値を保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.square2へ保存します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+4</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4004</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+5</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4005</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4006</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA ソフト_APU_COMPORTS+7</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4007</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_sq2_old ;先ほど$4007に書き込んだ値を保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.三角形</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+8</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+10</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400A</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+11</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400B</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ノイズ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+12</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400C</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports+14</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400E</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+15</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400F</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これで、チャンネルの4番ポートに最後に書き込まれた値を記録する変数ができました。 次のステップでは、書き込む前にチェックを追加しています。<br><br><span style="font-family: Courier New">se_set_apu:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4000</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4001</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+2</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4002</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+3</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">cmp sound_sq1_old ;前回の書き込みとの比較</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> beq .square2 ;等しかったらこのフレームを書き込まない</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4003</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_sq1_old ;今書いた値を$4003に保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.square2。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+4</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4004</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+5</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4005</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4006</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+7</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">cmp sound_sq2_old</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> beq .トライアングル</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4007</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_sq2_old ;先ほど$4007に書き込んだ値を保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.triangleに保存します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+8</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4008</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports+10 ;4009は無いのでスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400A</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports+11</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400B</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ノイズ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOFT_APU_PORTS+12</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400C</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports+14 ;400Dが無いのでスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400E</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda soft_apu_ports+15 (ソフトアプポートポート15)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $400F</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>最後に初期化についてですが、本当に心配しなければならないのは、ゲーム内で最初に曲が再生される場合だけです。 sound_sq1_oldとsound_sq2_old変数を$00に初期化するとどうなるか考えてみましょう。 これは、起動時（RESET）、$4003/$4007に書き込んだ最後のバイトが$00だったとするものですが、もちろん、これは正しくありません。 起動時にこれらのポートへの書き込みは一度も行われていないのですから。もし$00に初期化すると、最初に演奏される曲の最初の音のピリオドの上位3ビットが$00だった場合、スキップされてしまいます。 これは望ましいことではありません。 代わりに、これらの変数を$4003/$4007に決して書き込まれない値、例えば$FFなどに初期化するべきです。 これにより、ゲーム中に最初に演奏する音がスキップされないことを保証します。<br><br style="font-family: Courier New"><span style="font-family: Courier New">sound_init:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$0F</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta $4015 ;スクエア1、スクエア2、トライアングル、ノイズの各チャンネルを有効にします。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_disable_flag ;無効化フラグをクリアする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;後で、他に初期化したい変数があれば、ここで初期化します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">lda #$FF</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta sound_sq1_old</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta sound_sq2_old</span><br style="font-family: Courier New"><span style="font-family: Courier New">se_silenceです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA #$30</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">sta soft_apu_ports ;スクエア1の音量を0に</span>する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta soft_apu_ports+4 ;スクエア2の音量を0に設定</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta soft_apu_ports+12 ;ノイズの音量を0に設定</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">sta soft_apu_ports+8 ;サイレンストライアングル</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br><font size="4"><b>休符</b></font><br><br>このレッスンの最後のトピックは休符です。<b>休符</b>は音符と音符の間にある無音の期間です。 音符と同じように、休符は4分休符、半休符、全休符など様々な長さがあります。<br><br>そこで、休符を特殊な音符とみなして、ノートテーブルでダミーのピリオドを与えます。 そして、データストリームからバイトをフェッチして、そのバイトがノートであると判断したときに、そのノートが休符であるかどうかを確認するための特別な検査を追加します。 もし、そうであれば、ストリームをシャットダウンすることを確認するのです。<br><br>まず、休符をノートテーブルに追加します。 これにはダミーのピリオドを付けます。 どんな値を使ってもかまいませんが、ここでは$0000とします。 また、休符をノートエイリアスのリストにも追加します。<br><br><span style="font-family: Courier New">note_table。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word $07F1、$0780、など....</span><br style="font-family: Courier New"><span style="font-family: Courier New">;....その他のノートテーブルの値はこちら</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.word $0000 ;残り。 最後のエントリ</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">注：音楽のオクターブは、伝統的にAではなくCから始まります。 </span><br style="font-family: Courier New"><span style="font-family: Courier New">A1 = $00 ;1 "はオクターブ1を意味します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">As1 = $01 ;sは "シャープ "を意味します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">Bb1 = $01 ;bは "フラット "の意味 A# == Bb なので、同じ値です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">B1 = $02</span><br style="font-family: Courier New"><span style="font-family: Courier New">;...... 他の別名はこちら</span><br style="font-family: Courier New"><span style="font-family: Courier New">F9 = $5c</span><br style="font-family: Courier New"><span style="font-family: Courier New">Fs9 = $5d</span><br style="font-family: Courier New"><span style="font-family: Courier New">Gb9 = $5d</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">rest = $5e</span><br><br>restは5Eという値で評価され、音符の範囲（$00-$7F）に入ります。 サウンドエンジンはデータストリームで5Eに出会うと、ノートテーブルからピリオド（$0000）を取り出してRAMに保存します。 ピリオドが$0000というのは、実際には四角いチャンネルを消すには十分低いのですが、三角形のチャンネルはこのピリオドでも聞こえるので、まだやるべきことは残っています。<br><br><b>休符のチェック</b><br>休符に遭遇したとき、次の音符が出るまでこのストリームを停止するようにサウンドエンジンに指示したい。 休符は他のすべての音符とは異なる機能なので、コード内で特別なチェックをする必要がある。 これを行うサブルーチン se_check_rest を作成することにしよう。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.フェッチ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length: ;do Note Length stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ノート: ;ノートに関すること</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;インデックスをデータストリームに保存する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;データストリームのインデックスを復元する。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">;休符かどうかチェック</span>する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jsr se_check_rest </span><br style="font-family: Courier New"><span style="font-family: Courier New">.update_pointer:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tya</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inc ストリーム_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New">.end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>se_check_rest はノートの値が $5E と等しいかどうかをチェックします。 等しい場合は、サウンドエンジンにストリームを消すように指示する必要があります。 ノートが $5E と等しくない場合は、楽しい道を行くことができます。<br><br>ストリームの音量 (stream_vol_duty) は曲のヘッダで設定されていることを思い出してください。 se_set_temp_ports は stream_vol_duty の値を soft_apu_ports にコピーします。もし se_check_rest に stream_vol_duty 変数を直接変更 (ボリュームを 0 にする) させると、古いボリューム値は消えてしまいます。 rest が終わったときにそれを何に戻せばいいのかわからなくなります。 いやー!<br><br>その代わり、stream_vol_duty はそのままにしておきます。 通常通り毎フレーム soft_apu_ports にコピーします。 そして、コピー後に現在休憩中かどうかをチェックします。 もし休憩中なら、ボリュームを 0 にする値で再度 soft_apu_ports に書き込みます。 理解できましたか?<br><br><b>stream_status</b><br>もし、サウンドエンジンがデータストリームで$5Eに遭遇したら、休息状態をオンにします。 もし、そうでなければ、休息状態をオフにします。 オンかオフの2つの可能性しかありません。 変数の全く新しいブロックを宣言して、6バイトのRAMを無駄にするより、 stream_status変数のビットの1つを休息の指標に割り当ててみましょう。<br><br style="font-family: Courier New"><span style="font-family: Courier New">ストリーム・ステータス・バイト</span><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ||</span><br style="font-family: Courier New"><span style="font-family: Courier New"> |+- Enabled (0: ストリームが無効、1: 有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> +-- 休息 (0: 休息していない; 1: 休息している)</span><br><br>新しいサブルーチンse_check_restは、ステータスバイトのこのビットのセットまたはクリアを担当する。<br><br><span style="font-family: Courier New">se_check_rest:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;ノートバイトをもう一度読みます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #rest ;休符なのか？(==$5E)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .not_rest</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ora #%00000010 ;もしそうなら、statusバイトにrestビットをセットする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .store ;これは必ず分岐する。bneはjmpより安い。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.not_rest:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> and #%11111101 ;ステータスバイトの残りのビットをクリアする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.store。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>次に、残りのビットをチェックし、それが設定されている場合、ストリームを沈黙させるためにse_set_temp_portsを変更します。<br><br><span style="font-family: Courier New">se_set_temp_ports:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_vol_duty, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports, y ;vol</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$08</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+1, y ;スイープ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+2, y ;周期LO</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+3, y ;周期 HI</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> もし<span style="color: rgb(255, 0, 0)">設定されていれば、静寂の値でボリュームを上書き </span>する。         </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_status, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> と#%00000010</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> beq .done ;クリアされた場合、レストはないので終了</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_channel, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> cmp #TRIANGLE ;もし、三角形なら、#$80で無音にする。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> beq .tri </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda #$30 ;そうでなければ、#$30で終了</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .store ;これは常に分岐する。bneはjmpより安い。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.tri:</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.store。 </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta soft_apu_ports, y</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これで、私たちのエンジンは休符をサポートしました！休符は音符と同じように機能するので、その長さは音符の長さと同じように制御されます。<br><br style="font-family: Courier New"><span style="font-family: Courier New">song_data: ;このデータには2つの4分休符があります。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte half, C2, quarter, rest, eighth, D4, C4, quarter, B3, rest</span><br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/tempo.zip" target="_blank" original-href="http://tummaigames.com/tempo.zip">tempo.zipの</a>サンプルファイルをダウンロードして解凍します。 以下のファイルがNESASM3と同じフォルダにあることを確認してください。<br><br>tempo.asm<br>sound_engine.asm<br>tempo.chr<br>note_table.i<br>note_length_table.i（ノートテーブル<br>song0.i<br>song1.i<br>曲2.i<br>曲3.i<br>曲4.i<br>曲5.i<br>tempo.bat<br><br>tempo.batをダブルクリックします。NESASM3が実行され、tempo.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラを使って曲を選択し、再生します。 コントロールは以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>：次の曲/SFX<br><b>左</b>: 前の曲/SFX<br><br>tempo.asm は、song0 を「再生」して、押さえたときに音楽を停止します。 その仕組みは、song0.i を参照してください。<br>Song1は、先週のマイナーサードの邪悪な音の連続ですが、テンポ設定のおかげで、より速くなりました。<br>Song2は先週と同じ短い効果音です。<br>Song3はシンプルな下降コード進行で、音符の長さを利用してトライアングルデータのバイト数を節約しています（先週のファイルとの比較）。<br>Song4は、可変ノート長と休符を紹介する新曲です。<br>Song5は短い効果音で、10音を非常に速く演奏します。 曲に重ねて演奏し、音楽からSQ2チャンネルをどのように奪うかを見てください。<br><br>独自の曲や効果音を作って、ミックスに追加してみてください。 新しい曲を追加するには、次の手順が必要です。<br><br>1) ソングヘッダとソングデータを作成します（同梱のソングを参考にしてください）。 ヘッダの各ストリームにテンポを追加することを忘れないでください。 データストリームは$FFで終了されます。<br>2) sound_engine.asm の下部にある song_headers ポインタ・テーブルにヘッダを追加します。<br>3) 定数 NUM_SONGS を更新して、新しい曲数の合計を反映させる (これも sound_engine.asm の一番下にある)<br><br>必要ではありませんが、song0.i, song1.i, song2.i, song3.iで行ったように、曲データを別のファイルに保存することをお勧めします。 この場合、ファイルをincludeするのを忘れないようにしてください。<br><br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253">ボリューム・エンベロープ</a><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-6__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-7">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。第7回：ボリューム・エンベロープ</h2>
      </div>
      <div class="mdl-card__supporting-text">
        先週<span style="font-weight: bold">：</span> <a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=24885">テンポ、音符の長さ、バッファリング、休符</a><br><br><span style="font-weight: bold">今週は</span>ボリュームエンベロープ<br><font size="4"><b><br>ボリュームエンベロープ</b></font><br><br>今週は、ボリュームエンベロープをエンジンに追加します。<span style="font-weight: bold">ボリュームエンベロープは</span>、一度に1フレームずつノートに適用される一連のボリューム値です。 例えば、次のようなボリュームエンベロープがあるとします。<br><br><span style="font-family: Courier New">F E D C 9 5 0</span><br><br>すると、音を出すたびに、最初のフレームでF、2番目のフレームでE、次にD、C、9、5と音量が上がり、最後に7番目のフレームで0になり消えます。 このボリュームエンベロープを適用すると、音はシャープで短いスタッカートの感じになります。 反対に、次のようなボリュームエンベロープがあるとします。<br><br><span style="font-family: Courier New">1 1 2 2 3 3 4 4 7 7 8 8 a a c c d d e e f f</span><br><br>それぞれの音はとても静かに始まり、フルボリュームにフェードインしていきます。 このボリューム・エンベロープを見てください。<br><br><span style="font-family: Courier New">d d d c b 0 0 0 0 0 0 0 0 6 6 5 4 0</span><br><br>ここでは、大きな音量（D）から始めて5フレーム鳴らし、8フレーム無音にした後、5フレーム非常に小さな音量で音を戻します。 このボリュームエンベロープを使った音は、かすかなエコーがあるように聞こえます。<br><br>このように、ボリュームエンベロープはとてもクールです。 いろいろな音を出すことができます。 それを追加してみましょう。<br><br><b>チャンネル</b><br>ボリュームエンベロープは、ボリュームを完全にコントロールできる square と noise チャンネルに最適です。 一方、triangle チャンネルは、ボリュームをあまりコントロールできません。 フルブラストとオフの2つの設定しかありません。 しかし、限定的にボリュームエンパイアを適用できます。 次の2つのボリュームエンパイアを見てください。<br><br><span style="font-family: Courier New">0f 0e 0d 0c 09 05 00</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">04 04 05 05 06 06 07 08 08 09 09 0a 0a 00</span><br><br>この2つのエンベロープは、スクエアチャンネルでは全く異なるサウンドになりますが、トライアングルチャンネルでは次のようになります。<br><br style="font-family: Courier New"><span style="font-family: Courier New">On On On On On On Off</span><br style="font-family: Courier New"><span style="font-family: Courier New">On On On On On On On On On On On Off</span><br><br>音量の微妙な変化はありませんが、長さが違います。 ボリュームエンベロープの末尾を00にすれば、三角形のキーオフをコントロールできます。 完全なボリュームコントロールほどクールではありませんが、それでも便利です。<br><br><b>ボリューム・エンベロープを定義する</b><br>まず、いくつかのボリュームエンベロープを定義して、作業するためのデータを用意しましょう。 上で示した例のいくつかを使います。<br><br><span style="font-family: Courier New">se_ve_1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $0F, $0E, $0D, $0C, $09, $05, $00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $FF</span><br style="font-family: Courier New"><span style="font-family: Courier New">se_ve_2:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01、$01、$02、$03、$04、$04、$07、$07</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $08, $08, $0A, $0A, $0C, $0C, $0D, $0D, $0E, $0E</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $0F、$0F</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト $FF</span><br style="font-family: Courier New"><span style="font-family: Courier New">se_ve_3:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $0D, $0D, $0C, $0B, $00, $00, $00, $00, $00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $00、$00、$00、$06、$06、$05、$04、$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト $FF</span><br><br>各エンベロープを$FFで終了させていることに注意してください。 エンベロープの終わりに到達したことをエンジンが知ることができるように、何らかのターミネータ値が必要です。 任意の値を使用することもできますが、$FFはかなり一般的です。<br><br>次に、ボリュームエンベロープのアドレスを保持するポインタテーブルを作成します。<br><br><span style="font-family: Courier New">ボリュームエンベロープのアドレスを保持するポインタテーブルを作成します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード se_ve_1, se_ve_2, se_ve_3</span><br><br><b>変数の宣言</b><br>ボリュームエンベロープを特定のストリームに適用するために、どのエンベロープを使用するかを示す変数が必要です。 また、ボリュームエンベロープ内の現在の位置を示すインデックス変数も必要です。<br><br><span style="font-family: Courier New">stream_ve .rs 6 ;現在のボリュームエンベロープ</span><br style="font-family: Courier New"><span style="font-family: Courier New">stream_ve_index .rs 6 ;ボリュームエンベロープ内の現在の位置</span><br><br>stream_ve は、どのボリュームエンベロープを使うかを教えてくれます。 コード的には、ポインタテーブルのインデックスとして働き、どこから読み込むかがわかります。 聞き覚えがありますか？ 曲を読み込むときの "song number" と同じように働きます。 まだ、そこまで行っていませんが、これらの変数を使って、ボリュームエンベロープから読み込む方法を覗いてみましょう。(xはストリーム番号):<br><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;これから破壊するので、yを保存します。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ve, x ;どのボリュームエンベロープか？</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl aアドレス(ワード)のテーブルをインデックスしているので2倍する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda volume_envelopes, y ;ポインタテーブルからアドレスの下位バイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda volume_envelopes+1, y ;アドレスのハイバイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy stream_ve_index, x ;ボリュームエンベロープ内の現在の位置。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;値を取得します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> この値は、$FF(終端値)と比較する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 音量を設定する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> stream_ve_indexをインクリメントする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> その他</span><br><br>このコードをsound_loadルーチンの冒頭と比較してみてください。 パターンが見えてきましたか？<br><br><b>初期化</b><br>新しい機能を追加するときはいつでも、それをどのように初期化するかを考える必要があります。 音楽データの各ストリームは異なるボリュームエンベロープを持つ可能性があるので、ヘッダーにボリュームエンベロープフィールドを追加します。 ボリュームエンベロープは、これまでの「初期音量」フィールドを廃止しますが、デューティサイクル情報はまだ必要なので、このフィールドをリネームすることにしましょう。<br><br><span style="font-family: Courier New">メインヘッダ。</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">byte #｜ それが教えてくれること</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00｜ストリーム数</span><br style="font-family: Courier New"><span style="font-family: Courier New">01+｜ ストリームヘッダ（各ストリームに1つずつ配置）</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">ストリームヘッダです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">バイト数｜何がわかるか</span><br style="font-family: Courier New"><span style="font-family: Courier New">--------+----------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">00｜どのストリームか(ストリーム番号)</span><br style="font-family: Courier New"><span style="font-family: Courier New">01｜ステータスバイト</span><br style="font-family: Courier New"><span style="font-family: Courier New">02｜どのチャンネルか</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">03｜初期デューティ（三角形の場合は7bitに設定）</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">04｜音量エンベロープ</span><br style="font-family: Courier New"><span style="font-family: Courier New">05-06｜データストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New">07｜初期テンポ</span><br><br>このデータをヘッダーから読み出すには、以下のコードをsound_loadルーチンに挿入する必要があります（dutyを読み出した後）。<br><br><span style="font-family: Courier New"> lda [sound_ptr], y ;ストリームのボリュームエンベロープ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ve, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br><br>音符は常にボリュームエンベロープの先頭から始まるので、stream_ve_indexを0に初期化すればよいのです。<br><br><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ve_index, x</span><br><br>あとは、ソングデータ内のすべてのストリームにボリュームエンベロープを割り当てるだけで、準備は完了です。<br><br><span style="font-family: Courier New">song5_header:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;1ストリーム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SFX_1 ;どのストリームか？</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト(ストリーム有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SQUARE_2 ;どのチャンネルか。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $70 ;初期デューティ(01) 初期ボリュームは非推奨。</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.byte $00 ;最初のボリュームエンベロープ(se_ve_1)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song5_square2 ;ストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $FF ;テンポ...超高速テンポ</span><br><br>どの番号がどの番号かを覚えておきたくない場合は、いつでもボリュームエンベロープに説明的なエイリアスを作成できることを忘れないでください。<br><br><span style="font-family: Courier New">;ボリュームエンベロープの別名</span><br style="font-family: Courier New"><span style="font-family: Courier New">VE_SHORT_STACCATO = $00</span><br style="font-family: Courier New"><span style="font-family: Courier New">ve_fade_in = $01</span><br style="font-family: Courier New"><span style="font-family: Courier New">ヴェ_ブリップ_エコー = $02</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">歌5_header:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;1ストリーム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SFX_1 ;どのストリームか</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト(ストリーム有効)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte SQUARE_2 ;どのチャンネルか。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $7F ;初期デューティ(01). 初期ボリュームは非推奨。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte<span style="color: rgb(255, 0, 0)">ve_short_staccato</span>;最初のボリュームエンベロープ(se_ve_1)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song5_square2 ;ストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $FF ;テンポ...超高速テンポ</span><br><br>エイリアスを使うのは良いアイデアです。エイリアスを間違って入力すると、アセンブラはエラーを出します。 もし番号を間違って入力しても、それが有効な番号なら、アセンブラは問題があることを知らずに組み立ててしまいます。 データのこの種のバグは、追跡が難しいことがあります。<br><br><br><font size="3"><b>ボリュームエンベロープの実装</b></font><br><br>ボリュームエンベロープを実装するには、ボリュームを設定するコードを変更する必要があります。 以前のように固定値を使用するのではなく、ボリュームエンベロープの現在の位置から読み取り、その値を使用します。 ボリュームコードは少し複雑になり始めたので、独自のサブルーチンに引き出しましょう。 これにより、コードはより簡単になります。<br><br><span style="font-family: Courier New">;----------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">; se_set_temp_ports はストリームのサウンドデータを一時的なapu変数にコピーします。</span><br style="font-family: Courier New"><span style="font-family: Courier New">; input:</span><br style="font-family: Courier New"><span style="font-family: Courier New">X: ストリーム番号</span><br style="font-family: Courier New"><span style="font-family: Courier New">se_set_temp_ports:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_CHANNEL, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jsr se_set_stream_volume ;ボリュームのコードをすべて新しいサブルーチンに貼り</span>付けましょう。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> その方が散らからな�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$08</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+1, y ;スイープ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+2, y ;周期LO</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports+3, y ;周期 HI</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> rts </span><br><br>新しいサブルーチン se_set_stream_volume は何をすべきでしょうか？ まず、ストリームのボリュームエンベロープから値を読み取る必要があります。 次に、その値を使ってストリームのボリュームを変更する必要があります。 そして、ボリュームエンベロープ内の位置を更新します。 最後に、休憩しているかどうか確認し、休憩していればストリームを停止します（このコードは先週書いた）。 このようなコードです（赤い部分が新しいコードです）。<br><br><br><span style="font-family: Courier New">se_set_stream_volume:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">sty sound_temp1 ;save our index into soft_apu_ports (we are about to destroy y)</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_ve, x ;どのボリュームエンベロープか？</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> asl aアドレス(ワード)のテーブルにインデックスを付けるので、2倍する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> tay</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda volume_envelopes, y ;ポインタテーブルからアドレスの下位バイトを取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta sound_ptr ;それをポインタ変数に格納します。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda volume_envelopes+1, y ;アドレスの上位バイトを取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta sound_ptr+1</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.read_ve:</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> ldy stream_ve_index, x ;ボリュームエンベロープ内の現在の位置。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda [sound_ptr], y ;値を取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> cmp #$FF</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .set_vol ;FFでなければ、音量を設定する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> dec stream_ve_index, x ;else if FF, 1つ前に戻って読み直す。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jmp .read_ve ;FFは基本的に最後の読み込みを繰り返すよう指示する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> 音符の残りの部分のために ; ボリューム値を繰り返すように指示す�</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.set_vol:</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta sound_temp2 ;新しいボリューム値を保存 (Aを破壊しようとしている)</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_vol_duty, x ;現在のボリューム/デューティ設定を得る</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> and #$F0 ;古いボリュームをゼロにする</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> ora sound_temp2 ;新しいボリュームをORする。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> ldy sound_temp1 ;soft_apu_portsのインデックスを取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta soft_apu_ports, y ;テンポラリポートにボリュームを格納する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> inc stream_ve_index, x ;ボリュームエンベロープのインデックスを次の位置に設定する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><br style="font-family: Courier New"><span style="font-family: Courier New">.rest_check:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> もし設定されていれば、沈黙の値でボリュームを上書きする </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#%00000010</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .done ;もしクリアなら、休息はないので終了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE ;もし三角形なら、#$80で無音にする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .tri ;さもないと、#$30で沈黙する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .store ;これは常に分岐する。bneはjmpより安い</span><br style="font-family: Courier New"><span style="font-family: Courier New">.tri。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80</span><br style="font-family: Courier New"><span style="font-family: Courier New">.store。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports, y</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>ボリュームエンベロープから値を読み込んだ後、stream_vol_duty を #$F0 と AND します。 これは、四角形のデューティサイクル設定を維持しながら古いボリュームをクリアする素晴らしい効果があります。 しかし、ここで注意する必要があります。 三角チャネルのオン/オフ状態は、ポートの下位 7 ビットで制御されていることを思い出してください。<br><br style="font-family: Courier New"><span style="font-family: Courier New">tri_ctrl ($4008)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">||||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">|+++++++- 値</span><br style="font-family: Courier New"><span style="font-family: Courier New">+-------- 制御フラグ (0: 内部カウンタを使用; 1: 内部カウンタを無効にする)</span><br><br>これらのValueビットのいずれかがセットされていれば、三角形チャンネルはオンとみなされます。 もしビット4、5、6がたまたまセットされていたらどうなるか考えてみましょう。 この場合、#$F0とのAND処理では三角形チャンネルをオフにすることはできません。ボリュームエンベロープから取り出したボリュームが 0 なら、ビット 4、5、6 がセットされたままなので、三角形のチャンネルを消すことはできません。 ソングヘッダにこれらのビットをセットしないように注意すれば、この問題は発生しないはずです。 しかし、念のため修正しておく必要があるでしょう。<br><br><span style="font-family: Courier New">se_set_stream_volume:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;save our index into soft_apu_ports (we are about to destroy y) ソフトウエアポートにインデックスを保存します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ve, x ;どのボリュームエンベロープか？</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl aアドレス(ワード)のテーブルにインデックスを付けるので、2倍する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda volume_envelopes, y ;ポインタテーブルからアドレスの下位バイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr ;それをポインタ変数に格納します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda volume_envelopes+1, y ;アドレスの上位バイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.read_ve:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy stream_ve_index, x ;ボリュームエンベロープ内の現在の位置。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;値を取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FF</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .set_vol ;FFでなければ、音量を設定する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec stream_ve_index, x ;else if FF, 1つ前に戻って読み直す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .read_ve ;FFは基本的に最後の読み込みを繰り返すよう指示する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 音符の残りの部分のために ; ボリューム値を繰り返すように指示す�</span><br style="font-family: Courier New"><span style="font-family: Courier New">.set_vol:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_temp2 ;新しいボリューム値を保存 (Aを破壊しようとしている)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">cpx #TRIANGLE </span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .squares ;三角形のチャンネルでない場合は、先に進む</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda sound_temp2</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .squares ;else if volume not zero, go ahead (treat same as squares)</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda #$80</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bmi .store_vol ;else #$80でチャンネルを消す</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.squares。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_vol_duty, x ;現在のボリューム/デューティ設定を得る</span><br style="font-family: Courier New"><span style="font-family: Courier New"> and #$F0 ;古いボリュームをゼロにする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ora sound_temp2 ;OR私たちの新しいボリュームで。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.store_vol:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;soft_apu_portsに私たちのインデックスを取得します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports, y ;テンポラリポートにボリュームを格納します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inc stream_ve_index, x ;ボリュームエンベロープのインデックスを次の位置に設定する。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.rest_check:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> もし設定されていれば、沈黙の値でボリュームを上書きする </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#%00000010</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .done ;もしクリアなら、休息はないので終了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE ;もし三角形なら、#$80で無音にする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .tri ;さもないと、#$30で沈黙する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .store ;これは常に分岐する。bneはjmpより安い</span><br style="font-family: Courier New"><span style="font-family: Courier New">.tri。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80</span><br style="font-family: Courier New"><span style="font-family: Courier New">.store。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta soft_apu_ports, y</span><br style="font-family: Courier New"><span style="font-family: Courier New">.done:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br><b>新しい音符</b><br>最後に、新しい音符について考えてみましょう。 古い音符が終わり、新しい音符を演奏し始めるとき、ボリュームエンベロープを最初にリセットしたいと思います。 これは、新しい音符を読むときに stream_ve_index を 0 に設定するのと同じくらい簡単なことです。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> se_fetch_byte: ;...snip... (ポインタの設定、バイトの読み込み、範囲のテストなど)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;ノートに関することをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;インデックスをデータストリームに保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;データストリームのインデックスを復元する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">lda #$00</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> sta stream_ve_index, x ;ボリュームエンベロープをリセットする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;レストであるかどうかをチェックし、ステータスフラグを適切に変更する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_check_rest </span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;スニップ... (ポインタを更新)</span><br><br>そして、ボリュームエンベロープができました。<br><br><b>まとめ</b><br><a href="downloads/NerdyNightsSoundSourceCollection/envelopes.zip" target="_blank" original-href="http://tummaigames.com/envelopes.zip">envelopes.zipの</a>サンプルファイルをダウンロードして解凍します。 以下のファイルがNESASM3と同じフォルダにあることを確認してください。<br><br>envelopees.asm<br>サウンドエンジン(SOUND_ENGINE.ASM)<br>エンベロープ.chr<br>note_table.i<br>note_length_table.i<br>vol_envelopes.i<br>曲0.i<br>曲1.i<br>曲2.i<br>曲3.i<br>song4.i<br>曲5.i<br>エンベロープ.bat<br><br>envelopes.batをダブルクリックします。NESASM3が実行され、envelopes.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラを使って曲を選択し、再生します。 コントロールは以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>：次の曲／SFX<br>左<b>： </b>前の曲/SFX<br><br>Song0は無音の曲で、選択不可。<br>Song1は、『ガーディアンレジェンド』のボス曲で、ほぼ原曲と同じです。<br>Song2は、先週と同じ短い効果音です。<br>Song3はドラゴンウォリアーの曲で、オリジナルに近い。<br>Song4は先週と同じSong4ですが、ボリュームエンベロープにより、休符を減らすことでバイトを節約しています。<br>Song5は先週と同じ、短い効果音です。<br><br>独自の曲や効果音を作って、ミックスに追加してみてください。 新しい曲を追加するには、次の手順が必要です。<br><br>1) ソングヘッダとソングデータを作成します（同梱のソングを参考にしてください）。 ヘッダの各ストリームにボリュームエンベロープを選択するのを忘れないでください。 データストリームは$FFで終端します。<br>2) ヘッダをsound_engine.asmの下部にあるsong_headersポインタ・テーブルに追加する。<br>3) 定数NUM_SONGSを更新して、新しい曲数の合計を反映させる (これもsound_engine.asmの一番下にある)<br><br>ボリュームエンベロープは$FFで終端することを忘れないでください。<br>
        <br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583">オペコード、ループ</a>処理<br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-7__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-8">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。パート8:オペコードとルーピング</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25253">巻紙封筒</a><br>
        <br>
       <b>今週は</b>オペコードとループ<br>
        <br>
       <font size="5"><b>オプコード</b></font><br>
        <br>サウンドエンジンは、音楽データストリームから読み込んだ音符と音符の長さの2種類のデータを扱います。 複雑な音楽を作るにはこれで十分ですが、もちろん、もっと多くの機能が必要になります。 音符の音をコントロールしたいのです。途中でデューティサイクルを変えたり、ボリュームエンベロープを変えたり、キーを変えたり、曲の一部を4回ループさせたり、曲全体を連続的にループさせたり、曲の一部として効果音を鳴らしたりするのはどうでしょう？<br><br>このような、エンジンにコマンドを発行する機能は、すべてオペコード（コントロールコード、コマンドコードとも呼ばれます）を通じて行われます。<b>オペコードは</b>、データストリーム中の値で、エンジンに特定の特殊なサブルーチンやコードの一部を実行するように指示します。 ほとんどのオペコードには、<b>引数が</b>一緒に送られます。 たとえば、ストリームのボリュームエンベロープを変更するオペコードには、変更するボリュームエンベロープを指定するための引数が付属しています。<br><br>実は、あるオペコードを何週間も使っているのですが、そのことについて触れていませんでした。 それは音を終了させるオペコードで、データストリームでは$FFとしてエンコードしています。 以下は、そのコードです。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip--- (バイトをフェッチして範囲テスト)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;do Opcode stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FF</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x ;if $FF, ストリームの終わり, だからそれを無効にして沈黙する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#%11111110</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_status, x ;ステータスバイトの有効フラグをクリアする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .silence_tri ;三角形は四角形やノイズと異なる方法で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30 ;四角錐とノイズは#$30で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .silence</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence_tri。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80 ;三角形は#$80で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_vol_duty, x ;ストリームのボリューム変数に無音値を格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .update_pointer ;完了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip--- (音符の長さ、音符の数、ストリームのポインタの更新を行う)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>ここでは、読み込んだバイトが$FFの値を持っているかどうかをチェックします。 もしそうなら、ストリームをオフにして沈黙させます。 これはオペコードです。<br><br>このように、すべてのオペコードをそのまま書いてしまうと、かなり面倒です。 通常は、このコードを次のように独自のサブルーチンに引き込みます。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip--- (バイトをフェッチして範囲テスト)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;さもないとオペコードになる</span><br style="font-family: Courier New"><span style="font-family: Courier New">;do Opcode stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FF ;エンドサウンドオプコード</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .end</span><br style="font-family: Courier New"><span style="color: rgb(255, 0, 0); font-family: Courier New">jsr se_op_endsound ;エンドサウンドサブルーチンを呼び</span>出す<br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .fetch ;ストリームの次のバイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip--- (音符の長さと音符を行う、ストリームのポインタを更新する)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_endsound:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x ;ストリームが終了したので、それを無効にして無音にする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と #%11111110</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_status, x ;ステータスバイトの有効フラグをクリアする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .silence_tri ;三角形は四角形やノイズと異なる方法で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30 ;四角錐とノイズは#$30で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .silence</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence_tri。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80 ;三角形は#$80で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_vol_duty, x ;ストリームのボリューム変数に無音値を格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>.opcodeの枝はだいぶ短くなりました。 もし、もっと多くのオペコードを追加したければ、さらにいくつかの比較を追加すればよいでしょう。<br><br><span style="font-family: Courier New">.opcode。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;do Opcode stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FF ;エンドサウンドオペコードか？ </span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .not_FF</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jsr se_op_endsound ;もしそうなら、終了音のサブルーチンを呼び出す</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .end ;そして終了</span><br style="font-family: Courier New"><span style="font-family: Courier New">.not_FF:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FE ;さもなくばループのオペコードか？</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .not_FE</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jsr se_op_loop ;もしそうなら、ループサブルーチンを</span>呼び出す</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .opcode_done</span><br style="font-family: Courier New"><span style="font-family: Courier New">.not_FE:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$FD ;else is the change volume envelope opcode?</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .not_FD</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jsr se_op_change_ve ;もしそうなら、チェンジボリュームエンベロープのサブルーチンを呼び出す</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .opcode_done</span><br style="font-family: Courier New"><span style="font-family: Courier New">.not_FD:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode_done:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;データストリームの次のバイトのインデックスを更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp .fetch ;別のバイトを取りに行ってください。</span><br><br><br>これは動作しますが、醜いです。 エンジンにオペコードを追加するほど、多くのチェックが必要になります。 オペコードが20個あったらどうでしょう？ そんなに多くの比較をしたいでしょうか？ ROMスペースとサイクルの浪費です。<br><br><b>テーブル</b><br>1つの値に対して多数のCMPを実行するような状況に陥った場合は、<b>ルックアップテーブルを</b>使用します。 これにより、すべてが簡単になります。 すでに音符、音長、曲数、ボリュームエンベロープで使用しました。 ルックアップテーブルを使用せずに音価を取得しようとするとどうなるか想像できますか？ このような感じです。<br><br><span style="font-family: Courier New">この音はA1か？ もしそうなら、このピリオドを使う。</span><br style="font-family: Courier New"><span style="font-family: Courier New">A#1であれば、このピリオドを使用、そうでなければ</span><br style="font-family: Courier New"><span style="font-family: Courier New">音符がB1であれば、このピリオドを使う。</span><br style="font-family: Courier New"><span style="font-family: Courier New">C2なのか？</span><br style="font-family: Courier New"><b style="color: rgb(255, 0, 0)"><span style="font-family: Courier New">... (さらに約100のチェック)</span></b><br style="font-family: Courier New"><span style="font-family: Courier New">その音はF#9か？もしそうなら、このピリオドを使う、さもなくば</span><br style="font-family: Courier New"><span style="font-family: Courier New">その音は休符か？ もしそうなら、このピリオドを使う</span><br><br>これでは、何百行もの読めないコードになるし、分岐エラーも発生する。 ルックアップテーブルを使うと、コードはこのように単純化される。<br><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note: ;do Note stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;save our index</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tay</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> Sta stream_note_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;データストリームのインデックスを復元する。</span><br><br>繰り返しになりますが、1<b>つの値に対して多くのCMPを実行する場合は、テーブルを</b>使用するようにしてください。<br><br>音符や音符の長さについては、<i>ルックアップテーブルを</i>そのまま使い、曲番号や音量エンベロープについては、<i>ポインターテーブル</i>という特殊なルックアップテーブルを使って、データアドレスを格納しています。 オペコードについては、<b>ジャンプテーブルという</b>ものを使うか、<b>RTSテーブルを</b>使うかの2つの選択肢があります。 これらはほとんど同じで、2つの方法の性能差はごくわずかですから、ほとんどのプログラマにとっては個人の選択の問題でしかないのですが、私はRTSテーブルを好みます。<br><br>私自身はRTSテーブルの方が好きですが、説明や理解がしやすいという理由でジャンプテーブルを使うことにします。<br><br><b>ジャンプテーブル</b><br>サウンドエンジンには、10個以上のオペコードがあります。 それぞれのオペコードにはサブルーチンがあります。 サウンドエンジンがデータストリームからオペコードバイトを読み込むとき、CMP命令やBNE命令の長いリストを避けて、正しいサブルーチンを選択したいと思います。 そのためには、ジャンプテーブルを使用するのです。<br><br>ジャンプテーブルはポインターテーブルと似ていて、アドレスのテーブルです。 しかし、ポインターテーブルがデータの開始を指すアドレスを保持するのに対し、<b>ジャンプ</b>テーブルは<i>コードの</i>開始（つまりサブルーチンの開始）を指すアドレスを保持します。 たとえば、いくつかのサブルーチンがあるとします。<br><br><span style="font-family: Courier New">sub_a:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldx #$FF</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sub_b:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc #$03</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">sub_c:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 秒</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sbc #$03</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これらのサブルーチンを使ったジャンプテーブルは次のようになる。<br><br><span style="font-family: Courier New">sub_jump_table:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word sub_a, sub_b, sub_c</span><br><br>サブルーチンのラベルを使えば、アセンブラがそれをサブルーチンの開始アドレスに変換してくれます。 サウンドオペコードのサブルーチンのジャンプテーブルを作成してみましょう。<br><br><span style="font-family: Courier New">SE_OP_ENDSOUND:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> いろいろなことをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">SE_OP_INFINITE_LOOP:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> いろいろなことをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_change_ve:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 何かをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">その他のサブルーチン</span><br style="font-family: Courier New"><br>
       <span style="font-family: Courier New"> これはジャンプテーブル</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_opcodes:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード se_op_endsound</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード se_op_change_ve</span><br style="font-family: Courier New"><span style="font-family: Courier New"> その他、サブルーチンにつき1つのエントリ</span><br><br>さて、ジャンプテーブルができましたが、これをどのように使うのでしょうか？<br><br><b>間接的なジャンプ</b><br>6502では、いくつかのクールなことができます。 その1つが、間接ジャンプです。<b>間接ジャンプは</b>、ゼロページポインタ変数に目的地のアドレスを突っ込んで、そこにジャンプするものです。 このように動作します。<br><br><span style="font-family: Courier New">.rsset $0000</span><br style="font-family: Courier New"><span style="font-family: Courier New">まず、ゼロページのどこかにポインタ変数を宣言します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">jmp_ptr .rs 2 ;アドレスは常に1ワードなので2バイト</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp [jmp_ptr] ;8000ドルへジャンプします。</span><br><br>ここでは、変数<b>jmp_ptrに</b>アドレス（8000ドル、ローバイト先頭）を格納し、JMP命令の後に括弧でポインタ変数を記述して間接ジャンプを行います。<br><br><span style="font-family: Courier New"> jmp [jmp_ptr] ;間接ジャンプ</span><br><br>この命令を英訳すると「jmp_ptrとjmp_ptr+1に格納されているアドレスにジャンプせよ」という意味になります。 これは非常に便利で、好きなアドレスを格納することができます。<br><br><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$C0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp [jmp_ptr] ;$C000にジャンプします。</span><br><br>ROMからアドレスを読み込んで、それを使うこともできます。例えば、リセットベクターなどです。<br><br><span style="font-family: Courier New"> lda $FFFC</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda $FFFD</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp [jmp_ptr] ;リセットルーチンにジャンプします。</span><br><br>また、ジャンプテーブルと組み合わせて使うこともできます。<br><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_opcodes, y ;ジャンプテーブルからアドレスの下位バイトを読み込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_opcodes+1, y ;上位バイトを読み込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp [jmp_ptr] ;テーブルから取り出したアドレスにジャンプします。</span><br><br>かなり強力です。 動的に好きなコードセクションにジャンプできます!<br><br><b>実装</b><br>ジャンプテーブルの作り方と間接ジャンプのやり方はわかりました。 これをサウンドエンジンに組み込んでみましょう。 まずは<b>se_fetch_byteから</b>です。se_fetch_byteはデータストリームからバイトを読み、それが音符、音長、オペコードであるかどうかを範囲チェックします。 音符のバイト範囲は$00-$7F、音長のバイト範囲は$80-$9F、オペコードのバイト範囲は$A0-$FFであることを覚えておいてください。<br><br style="font-family: Courier New"><span style="font-family: Courier New">SE_FETCH_BYTE。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA STREAM_PTR_LO, X</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートだ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: </span><span style="color: rgb(255, 0, 0); font-family: Courier New">;else ($A0-$FF) それはopcode</span>です。<br style="font-family: Courier New"><span style="font-family: Courier New">;オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;音符の長さを指定する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ノート</span><br><br>そこで、オペコードを$A0から$FFの間の値に割り当てる必要があります。 ノートや音符の長さの場合と同様に、データストリームから読み取ったオペコードバイトはテーブルインデックスとして使用されます($A0を引いた後)ので、テーブルと同じ順番でオペコードを割り当てることになります。<br><br><span style="font-family: Courier New">sound_opcodes:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;これは$A0でなければなりません。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;これは$A1であるべきです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;これは$A2であるべきです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> その他、1サブルーチンにつき1エントリ</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">これらは、サウンドデータで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">loop = $A1 ;このあたりはコンフリクトに注意。</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム_エンベロープ = $A2</span><br><br>次に、se_fetch_byteを変更して、オペコードの世話をするようにしましょう。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New">.フェッチ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else ($A0-$FF) それはopcodeです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">;オペコードの</span>処理をする</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jsr se_opcode_launcher ;私たちのオペコードを起動する!!!</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> iny ;データストリームの次の位置</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_status, x</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> と#%00000001</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .fetch ;オペコードが終了した後、ストリームが無効になっていない限り、別のバイトを取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> rtsその場合は終了する(以下で説明)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length: ;音符の長さを指定する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 音符の処理をする</span><br><br>se_opcode_launcherというサブルーチンの呼び出しと、ちょっとしたブランチを追加しました。 大きな変化ではありませんね。 しかし、ここには重要な点があります。 se_opcode_launcherは、ジャンプテーブルから読み込み、間接ジャンプを行う短い、シンプルなサブルーチンになります。 このような感じになってますね。<br><br><span style="font-family: Courier New">SE_OPCODE_LAUNCHER:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;save y register, because we are about to destroy it</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sec</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sbc #$A0 ;オペコードバイトを$A0を引くことによってテーブルインデックスに変える</span><br style="font-family: Courier New"><span style="font-family: Courier New">; $A0-&gt;$00, $A1-&gt;$01, $A2-&gt;$02, etc....テーブルインデックスを$00から引きます�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a ;アドレス(ワード)のテーブルへのインデックスなので、2倍する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_opcodes, y ;サブルーチンのアドレスの下位バイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_opcodes+1, y ;ハイバイトを取得する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta jmp_ptr+1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;yレジスタの復元</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;データストリームの次の位置に設定する(引数を想定)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jmp [jmp_ptr] ;オペコードサブルーチンへの間接ジャンプ</span><br><br>では、なぜこのコードを独自のサブルーチンにラップしたのでしょうか？ なぜ、このコードをそのままse_fetch_byteの.opcodeブランチに刺さないのでしょうか？ それは、戻る場所が必要なのです。<br><br>JSR命令とRTS命令はペアで動作します。 この2つは手を取り合い、お互いを必要としています。 あまり細かいことは言いませんが、舞台裏ではこのようなことが行われています。<br>
        <br>
       <b>JSRは</b>スタックにリターンアドレスを書き込んで、サブルーチンにジャンプします。 JSRを、どこからスタートしたかを記憶しているJMPと考えるのも一法です。<br>
       <b>RTSは</b>、スタックからリターンアドレスを取り出して、そこにジャンプする。 <br>
        <br>
        つまり、JSRはRTSが後で拾えるように宝の地図を残しているのです。 ここで<b>重要な</b>のは、<b>RTSはスタック上にリターンアドレスが待っていることを期待して</b>いることです。<br><br>さて、オペコードサブルーチンはすべてRTS命令で終わりますが、ここで潜在的な問題があることがわかりますか？<br><br>オペコードサブルーチンを間接ジャンプで呼び出すには、JSR命令ではなくJMP命令を使う必要があります。 JMP命令は、自分がどこからスタートしたかを覚えていません。 JMP命令では、リターンアドレスがスタックにプッシュされません。そのため、オペコードのサブルーチンにジャンプして、最後にRTS命令を実行しても、リターンアドレスがありません！RTSは、その時点でスタック上にあるランダムな値を引っ張ってきて、そこにジャンプします。 ランダムな場所に行き着くので、プログラムがクラッシュすることは間違いありません。<br><br>これを解決するために、間接ジャンプをサブルーチン se_opcode_launcher でラップします。 これを JSR 命令で呼び出して、JSR/RTS のペアを完成させます。<br><br><span style="font-family: Courier New"> jsr se_opcode_launcher ;このjsrはどこから来たかを覚えさせます。</span><br><br>このJSR命令でスタックにリターンアドレスが記録されます。 そして、se_opcode_launcherの中で目的のオペコードサブルーチンに間接ジャンプします。 これで、オペコードサブルーチンの最後でRTS命令を打つと、スタック上にリターンアドレスが待っています。 プログラムは元の場所に戻り、安全です。<br><font size="4"><b><br>
            オペコードサブルーチン</b></font><br>オペコード・ランチャーができたので、オペコードを作る準備ができました。 すでに1つ、<b>endsoundという</b>オペコードを書いています。 これは効果音を終了させるためのオペコードです。 効果音は曲のように連続的にループしないので、止める必要があります。 もう一度見てみましょう。<br><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_endsound:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_status, x ;ストリームが終了したので、それを無効にして無音にします。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と #%11111110</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_status, x ;ステータスバイトの有効フラグをクリアする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_channel, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #TRIANGLE</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .silence_tri ;三角形は四角形やノイズと異なる方法で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$30 ;四角錐とノイズは#$30で消音される</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bne .silence ; (これは必ず分岐する。bneはjmpより安い)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence_tri:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$80 ;三角形を#$80で消音</span><br style="font-family: Courier New"><span style="font-family: Courier New">.silence。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_vol_duty, x ;ストリームのボリューム変数に無音値を格納する。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>このオペコードは特殊で、se_opcode_launcherの呼び出しの後にチェックが入るのはこのためである。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip---</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else ($A0-$FF) それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> オペコードの処理をする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_opcode_launcher</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;データストリームの次の位置</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">lda stream_status, x</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> と#%00000001</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .fetch ;オペコードが終了したら、ストリームが無効になっていない限り、別のバイトを取得する。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> rtsその場合は終了する(後述)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip---</span><br><br>通常、se_fetch_byteは音符にぶつかるまでバイトを取り続けます。 音符の長さについては、新しい音の長さを設定した後に.fetchにジャンプバックしたことを思い出してください。 これは、音の長さを設定した後に、どの音を演奏するか知る必要があるからです。 そこで、別のバイトを取得します。 同じことがオペコードについても言えます。オペコードでボリュームエンベロープを変更すれば素晴らしい！しかし、次に演奏する音を知る必要があります。しかし、次にどの音を鳴らすかを知る必要があります。 また、あるオペコードで四角形のデューティサイクルを変更しても、次にどの音を鳴らすかを知る必要があります。 あるオペコードで曲の最初にループバックしても、それはそれで素晴らしいのですが、曲の最初の音を読む必要があります。 オペコードを実行したらジャンプバックして1バイトをフェッチするのは、このためなのです。<br><br>このルールの唯一の例外は、サウンドエフェクトを終了するときです。 サウンドエフェクトを完全に終了するので、次の音はありません。 ないものをフェッチしたくないので、ジャンプをスキップする必要があります。 このため、オペコードを実行した後にステータスバイトをチェックします。 ストリームがendsoundオペコードで無効になっていれば終了です。 それ以外は次のバイトをフェッチします。<br><br><b>ループ処理</b><br>次のオペコードは、<b>ループオペコード</b>です。 これは、曲の最後に貼り付けて、サウンドエンジンに曲を何度も何度も再生させるためのオペコードです。 実装は非常に簡単で、<b>2バイトの引数を</b>とり、それが<b>ループバックするアドレス</b>になります。 サブルーチンは次のようなものです。<br><br style="font-family: Courier New"><span style="font-family: Courier New">SE_OP_INFINITE_LOOP:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;データストリームから引数のアドレスのLOバイトを読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x ;新しいデータストリームの位置として保存する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;read HI byte of the address argument from the data stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_HI, x ;新しいデータストリームの位置として保存する データストリームの位置</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1 ;新しい位置を反映させるためにポインタを更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$FF ;オペコードのリターン後、inyを行う。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ストリームバッファの位置をリセットしたので、yは再び0から始まるようにしたい�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>このサブルーチンは、データストリームから2バイトを読み込んでいます。 これは、オペコードと一緒に渡されるアドレス引数です。 これを明確にするために、サウンドデータの例を見てみましょう。<br><br><span style="font-family: Courier New">song1_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth ;音符の長さを8分音符に設定する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C5, E5, G5, C6, E6, G6, C5, Eb5, G5, C6, Eb6, half, G6 ;音を出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.byte loop ;このエイリアスは、ループのオペコードである$A1として評価さ</span>れます。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.word song1_square1 ;これは、song1_square1ラベルのアドレスに評価されます。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> すなわち、ループさせたいアドレスです。</span><br><br>この例では、ストリームデータの先頭にループバックすることにしました。<br><br>このアドレス引数の1バイト目（下位バイト）を読んでstream_ptr_LOに格納し、アドレス引数の2バイト目（上位バイト）を読んでstream_ptr_HIに格納しています。 これらは、データストリームの位置を追跡する変数です！ループオペコードは、これらの値を変更するだけです。ループオペコードは、これらの値を指定したアドレスに変更するだけです。 あまり複雑ではありません。 最後のステップは、実際のポインタ<b>（sound_ptr</b>）を更新して、データストリームから読み取った次のバイトが、ループバックした最初の音符になるようにすることです。<br><br>上のサウンドデータの例では、ストリームデータの先頭にループバックしていますが、他の場所にループすることを止めるものは何もありません。<br><br style="font-family: Courier New"><span style="font-family: Courier New">song1_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">イントロ、この部分はループさせない</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte quarter</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C4, C4, C4, C4</span><br style="font-family: Courier New"><span style="font-family: Courier New"><span style="color: rgb(255, 0, 0)">.loop_point:</span>;ここでループバックする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth ;音符の長さを8分音符にする</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C5, E5, G5, C6, E6, G6, C5, Eb5, G5, C6, Eb6, half, G6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.byte loop</span>;このエイリアスは、ループのオペコードである$A1として評価されます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.word .loop_point</span>;これは、.loop_pointラベルのアドレスに評価されます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> つまり、ループさせたい先のアドレス。</span><br><br>技術的には、前方の位置に「ループ」させることもできますが、その場合はループというよりジャンプに近いです。 ループは実際にはすべて、後方にジャンプすることなのです。<br><br><b>ボリュームエンベロープの変更</b><br>ボリュームエンベロープを変更するオペコードサブルーチンを書いてみましょう。 これはもっと簡単です。<b>引数を1</b>つ取り、<b>どのボリュームエンベロープに</b>切り替えるかを指定します。<br><br><span style="font-family: Courier New">se_op_change_ve:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;引数を読みます。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ve, x ;それをボリュームエンベロープ変数に格納します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ve_index, x ;ボリュームエンベロープのインデックスを最初に戻す</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>以上です。<br><br><b>デューティサイクルの変更</b><br>次に、正方形のストリームのデューティサイクルを変更するオペコードを追加してみましょう。 これも<b>1つの引数を取ります：どのデューティサイクルに</b>切り替えるかです。<br><br><span style="font-family: Courier New">se_op_duty:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;引数（どのデューティサイクルに切り替えるか）を読む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_vol_duty, x ;それを格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>完了！これでサブルーチンができましたが、まだジャンプテーブルに追加する必要があります。<br><br><span style="font-family: Courier New">sound_opcodes:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;これは$A0でなければなりません。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_loop ;これは$A1でなければなりません。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;これは$A2であるべきです。</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.word se_op_duty ;これは$A3であるべきです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> その他、1サブルーチンにつき1エントリ</span><br><br><span style="font-family: Courier New">これらは、サウンドデータで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">デューティ = $A3</span><br><br>そして、すぐに使えるようになる。<br><br><span style="font-family: Courier New">song0_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;イントロ、この部分はループさせないでください</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte quarter</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C4, C4, C4, C4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop_point:;これはループバックする場所である。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte<span style="color: rgb(255, 0, 0)"> duty, $B0</span>;デューティサイクルを変更する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.by<span style="color: rgb(255, 0, 0)">te volume_envelope, ve_blip_echo</span>;ボリュームエンベロープを変更する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">..byte eighth ;音符の長さを8分音符に設定する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C5, E5, G5, C6, E6, G6 ;音符を演奏する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte<span style="color: rgb(255, 0, 0)"> duty, $30 </span>;デューティサイクルの変更</span><br style="font-family: Courier New"><span style="font-family: Courier New">.by<span style="color: rgb(255, 0, 0)">te volume_envelope, ve_short_staccato</span>;ボリュームエンベロープを変更する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C5, Eb5, G5, C6, Eb6, half, G6 ;8分音符と2分音符を演奏する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop ;ループをかける.ループポイント </span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード .ループポイント</span><br><br><b>読みやすさ</b><br>sound_engine.asmはサブルーチンによってかなり大きくなっています。 オペコードを追加するとさらに大きくなります。 すべてのオペコードを1つの場所にまとめるのは良いことですが、スクロールして探すのは面倒です。 そこで、すべてのオペコードを独自のファイル、<b>sound_opcodes.asmに</b>まとめましょう。そしてsound_engine.asmの下部で、これをincludeすることができます。<br><br><span style="color: rgb(255, 0, 0)">.include "sound_opcodes.asm"</span>;オペコードのサブルーチン、ジャンプテーブル、エイリアスです。<br>.include "note_table.i" ;音符のための周期的なルックアップテーブル<br>.include "note_length_table.i" ;音符のピリオドのルックアップ・テーブル。<br>.include "vol_envelopes.i"(ボルエンベロープ)<br>.include "song0.i" ;曲0のデータ（ヘッダとデータストリーム）を保持する。<br>.include "song1.i" ;1曲目のデータを保持する。<br>.include "song2.i"(ソング2)<br>.include "song3.i"(ソング3)<br>.include "song4.i"(ソング4.i)<br>.include "song5.i"(ソング5)<br><span style="color: rgb(255, 0, 0)">.include "song6</span>.i" ;おお...新しい曲だ!<br><br>.asmという拡張子をつけたのは、データだけでなくコードも含まれていて、どのファイルに何が入っているか一目でわかるようにするためです。 これで、新しいオペコードを追加したり、古いものをいじったりしたいときに、それぞれのファイルにうまくコンパクトにまとめておくことができます。<br><br><b>サウンドデータの更新</b><br>サウンドエンジンに新しいものを追加するときはいつも、それが古いサウンドデータにどう影響するかを考えなければなりません。 今週は、歌と効果音の終了を変更するオペコードを追加しました。 以前は、$FFで終了していました。曲の場合は、"loop "の後にループ先のアドレスを指定します。 効果音の場合は、オペコード "endsound "で終了します。 例として、同梱の曲と効果音を見てください。<br><br><b>RTSテーブル</b><br>今週はジャンプテーブルと間接ジャンプについてお話しました。 同じことをするもうひとつの方法は<b>RTSテーブル</b>と<b>RTSトリックと</b>呼ばれるものです。 このチュートリアルではカバーしませんが、もしこれがどのように機能するか興味があれば、<a href="http://wiki.nesdev.com/w/index.php/RTS_Trick" target="_blank" original-href="http://wiki.nesdev.com/w/index.php/RTS_Trick">私が書いたRTSトリックについてのnesdev wiki記事を</a>読んでみてください。<br><br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/opcodes.zip" target="_blank" original-href="http://tummaigames.com/opcodes.zip">opcodes.zipの</a>サンプルファイルをダウンロードし、解凍します。 以下のファイルがNESASM3と同じフォルダにあることを確認します。<br><br>opcodes.asm<br>sound_engine.asm<br>sound_opcodes.asm<br>opcodes.chr<br>note_table.i<br>音長テーブル.i<br>vol_envelopes.i<br>song0.i<br>song1.i<br>曲2.i<br>曲3.i<br>song4.i<br>ソング5.i<br>曲6.i<br>opcodes.bat<br><br>opcodes.batをダブルクリックします。NESASM3が実行され、opcodes.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラーで曲を選んでプレイします。 コントロールは以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>次の曲/SFX<br><b>左</b>：前の曲/SFX<br><br>Song0は無音の曲で、選択できません。<br>Song1は、守護神伝説のボス曲です。 これでループします<br>Song2は先週と同じ短い効果音です。 endsoundで終了します。<br>Song3はDragon Warriorの曲で、現在ループしています。<br>Song4は先週と同じSong4ですが、今はループしています!<br>Song5は短い効果音で、endsoundオペコードで終了します。<br>Song6は、このフォーラムの読者にはおなじみだと思いますが、わかりますか？ デューティーサイクルとボリュームエンベロープを変更するためのオペコードを使用しています。 しかもループします。<br><br>自分の好きな曲や効果音を入れてみてください。 自分の好きなオペコードも入れてみてください。 いくつかオペコードのアイデアを紹介します。<br><br>1.曲の途中で効果音を鳴らす<br>2.デューティサイクルエンベロープ(ボリュームエンベロープのようなもの)を実装し、それを変更できるようなオペコードを作成する。<br>3.有限ループ<br><br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247">もっとオペコードを楽しもう 有限ループ、キー変更、オートメーション</a>... .<br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-8__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-9">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">
          オタクな夜の音。第9回：有限ループ、キー・チェンジ、コード・プログレッション        </h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583" target="_blank" original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=25583">オペコードとループ</a><br><br><b>今週は</b>もっとオプコードを有限ループ、キー・チェンジ、コード・プログレッション<br><br><font size="4"><b>オプコード</b></font><br>先週は、オペコードの使い方を学びました。 オペコードは、曲のストリームが再生中にサブルーチンを呼び出すことを可能にします。 これは非常に強力なツールです。 最も一般的なオペコードをいくつか学びました：無限ループ（実際にはジャンプ）、ボリュームエンベロープの変更、デューティサイクルの変更。 今日は、オペコードを拡張して、たくさんの（！）バイトと時間を節約できるクールなオペコードトリックを学ぶつもりです。<br><b><font size="3"><br>
            有限ループ</font></b><br>先週、無限ループのオペコードを追加しましたが、これは曲の以前の部分に無条件にジャンプバックするだけです。 今日は、有限ループのオペコードを追加します。 有限ループのオペコードは、サウンドエンジンに曲の特定の部分をX回繰り返すように指示します。 先週追加したBattle Kidのテーマソングには、次のような部分があります。<br><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 16teenth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, E4, E3, E2</span><br><br>これは本当に同じ4つの音符を何度も繰り返しているだけです。 代わりにこんなことができたらかっこよくないですか？<br><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 16teenth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop_13_times_please</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, E4, E3, E2</span><br><br>56バイトから10バイトに減りました。 バトルキッドの曲では、この同じフレーズを両方のスクエアチャンネルで演奏するので、100バイト以上から20バイト程度になります。 これは大きなことです！音楽の中で4や8の繰り返しがどれだけよく起こるかを考えると、有限ループオペコードがサウンドデータで数千バイトとは言わないまでも数百バイトを節約できることが容易にわかると思います。<br><br><b>有限ループとは？</b><br>有限ループとは、無限ループのことで、無限ループは無条件ジャンプのようなものです。 サウンドエンジンは、無限ループのオペコードを打つと、何があっても、問答無用でジャンプして戻ってきます。一方、有限ループは条件付きジャンプです。 カウンタをチェックし、カウンタが0でなければジャンプし、0であればジャンプしないのです。<br><b><br>
          ループカウンタ</b><br>まず最初に、ループカウンタが必要です。 各ストリームはループする機能を持つので、各ストリームにはそれ自身のループカウンタが必要です。<br><br><span style="font-family: Courier New">stream_loop1 .rs 6 ;ループ・カウンタ変数（各ストリームに1つずつ）</span><br><br>sound_loadのコードで、これを0に初期化します。<br><br><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_loop1, x</span><br style="font-family: Courier New"><br>次に、このカウンターを何らかの値に設定する方法が必要です。 ゲームによっては、これを有限ループのオペコードにまとめているものもありますが、私はこれを独自のオペコードにすることを好んでいます。<br><br><span style="font-family: Courier New">;-----------------------------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">これが私たちのジャンプテーブルです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">サウンドコード:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;$A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;$A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_duty ;$A3</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.ワードse_op_set_loop1_counter ;$A4</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> 等、サブルーチンにつき1エントリ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">これらは、サウンドデータで使用するエイリアスである。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">デューティ = $A3</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">set_loop1_counter = $A4</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_set_loop1_counter:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;引数を読む(ループ回数)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_loop1, x ;ループカウンタ変数に格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これで、ループカウンターをいつでも好きなときに設定する簡単な方法ができました。<br><br style="font-family: Courier New"><span style="font-family: Courier New"> サウンドデータのどこかに</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_loop1_counter, $04 ;4回繰り返す</span><br><b><br>
          カウンターを使ったループ</b><br>有限ループのオペコードは、無限ループのオペコードのように動作しますが、2つの変更があります。<br><br>1) ループカウンタをデクリメントする<br>2) ループの結果をチェックし、0でない場合にのみジャンプする。<br><br>では、書いてみましょう。<br><br><span style="font-family: Courier New">;-----------------------------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">これが私たちのジャンプテーブルです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">サウンド_OPCODE:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;$A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;$A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_duty ;$A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_set_loop1_counter ;$A4</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.ワード se_op_loop1 ;$A5</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> 等、サブルーチンにつき1エントリ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">これらは、サウンドデータで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">デューティ = $A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">set_loop1_counter = $A4</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">ループ1 = $A5</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_loop1:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec stream_loop1, x ;カウンタをデクリメントする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_loop1, x ;それをチェックする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .last_iteration ;もし0ならループ終了</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop_back:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;データストリームからptr LOを読み込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x ;データストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;read ptr HI from the data stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_HI, x ;我々のデータストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1 ;新しい位置を反映するためにポインタを更新する．</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$FF ;オペコードのリターン後、inyを行う。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ストリームバッファの位置をリセットしたので、yは再び0から始まるようにしたい�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><span style="font-family: Courier New">.last_iteration:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;アドレス引数の最初の1バイトをスキップする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;2バイト目はリターン時に自動的にスキップされます�</span><br style="font-family: Courier New"><span style="font-family: Courier New">; (se_fetch_byteを参照。jsr se_opcode_launcher" の後に "iny" がある)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これでループができるようになりました。 上のバトルキッドの例で言うと、次のようになります（56バイト）。<br><br><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, C4, E4, A4, A3, C4, E4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4, A3, E4, E3, E2</span><br><br>をこれ(13バイト)に変換します。<br><br><span style="font-family: Courier New">.byte set_loop1_counter, 13 ;13回繰り返す</span>。<br style="font-family: Courier New"><span style="font-family: Courier New">.intro_loop: ;ループポイントはカウンターをセットした後であることを確認してください!</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, C4, E4, A4 ;繰り返されるフレーズ。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop1 ;有限ループのオペコード</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word .intro_loop ;ジャンプバックするアドレス</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, E4, E3, E2 ;最後の4つの音符</span><br><br>このオペコードセットはよく使うことになりそうです。<br><br><b>ボーナス</b><br>この有限ループオペコードの.loop_backセクションのコードが無限ループのコードと同じであることにお気づきでしょうか。<br><br><span style="font-family: Courier New">se_op_loop1:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> se_op_loop1: ;---snip---</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop_back:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;データストリームから ptr LO を読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x ;データストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;read ptr HI from the data stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_HI, x ;我々のデータストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1 ;新しい位置を反映するためにポインタを更新する．</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$FF ;オペコードのリターン後、inyを行う。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ストリームバッファの位置をリセットしたので、yは再び0から始まるようにしたい�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip---</span><br><br>と比較する。<br><br><span style="font-family: Courier New">se_op_infinite_loop:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;データストリームからptr LOを読み出す。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x ;データストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;read ptr HI from the data stream</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_HI, x ;我々のデータストリームの位置を更新する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr+1 ;新しい位置を反映するためにポインタを更新する．</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_ptr</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy #$FF ;オペコードのリターン後、inyを行う。 </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ストリームバッファの位置をリセットしたので、yは再び0から始まるようにしたい�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>同じコードが2箇所にあるのはなぜでしょうか？ .loop_backセクションをすべてカットして、"jmp se_op_infinite_loop "に置き換えてみましょう。<br><br><span style="font-family: Courier New">se_op_loop1:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> dec stream_loop1, x ;カウンタをデクリメントする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_loop1, x ;カウンタをチェックする。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .last_iteration ;0ならループ終了</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">jmp se_op_infinite_loop ;ゼロでなければループバック</span>する</span><br style="font-family: Courier New"><span style="font-family: Courier New">.last_iteration:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny ;アドレス引数の最初の1バイトをスキップする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 2バイト目はリターン時に自動的にスキップされ�</span><br style="font-family: Courier New"><span style="font-family: Courier New">;（"jsr se_opcode_launcher" の後の se_fetch_byte を参照）�</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br><b>複数の有限ループ</b><br>なぜ有限ループのオペコードにloop1という名前をつけたのか、不思議に思われたかもしれません。 なぜ最後に1をつけたのか？ それは、有限ループのオペコードが一つでは十分でない場合があるからです。 次の曲の構造を考えてみましょう。 それぞれの文字が長い音符の連続を表していると仮定してください。<br><br><span style="font-family: Courier New"> A A A B C</span><br style="font-family: Courier New"><span style="font-family: Courier New"> A A B C</span><br style="font-family: Courier New"><span style="font-family: Courier New"> A A B C</span><br style="font-family: Courier New"><span style="font-family: Courier New"> A A B C</span><br><br>有限ループのオペコードを1つ使えば、このように減らすことができる。<br><br><span style="font-family: Courier New"> (A A B C)x4</span><br><br>しかし、有限ループのオペコードが2つ利用できれば、それを入れ子にしてさらに減らすことができる。<br><br><span style="font-family: Courier New"> (Ax3 B C)x4</span><br><br>もし、あなたが作る音楽がこのようなパターンをたくさん持っているなら、2つ以上の有限ループオペコードを用意して、それらをネストできるようにしておくとよいでしょう。 別の有限ループオペコードを追加するには、次のことが必要です。<br><br>1) RAM に別のループカウンタ変数ブロックを宣言する (stream_loop2 .rs 6)<br>2) sound_load ルーチンの中で、新しいループカウンタを 0 に初期化する。<br>3) 新しいループカウンタを設定するための新しいオペコードを追加する (se_op_set_loop2_counter)<br>4) 新しいカウンタとループをチェックする新しいオペコードを追加する (se_op_loop2)<br>5) 新しいオペコードをジャンプテーブルに追加し、エイリアスを与える (set_loop2_counter, loop2) ようにする。<br><br><br>追加する有限ループのオペコードはそれぞれ6バイトのRAM（限られた資源です！）を必要とするので、トレードオフの価値があるかどうか慎重に検討してください。 すべてはあなたの音楽データに依存します。<br><br>
        <br><b><font size="3">キーの変更</font></b><br><br>もう一つの便利な機能は、キーを変更する機能です。 曲を書いて、それがすべて完成したとします。 しかし、最後の最後で、別のキー、例えば一段（2音）低いキーにしたいと思いました。 曲全体を手で書き直す（永遠にかかる）よりも、すべての音から自動的に2を引くオペコードがあればいいと思いませんか？もし、複数のキーで演奏される曲のパターンがあったらどうでしょう（例えばブルース曲のリズムトラック）。 パターンを一度書いて、繰り返しキーを変えながらループさせる方法を考え出せば、たくさんのバイトを節約できるはずです。 やってみましょう。<br><br><b>ノートオフセット</b><br>ノートオフセットという変数を持って、キーを実装することにします。<br><br><span style="font-family: Courier New">stream_note_offset .rs 6 ;音符のオフセット</span><br><br>ノートオフセットはnote_tableからピリオドを取り出す前にノート値に加えられる値です。 stream_note_offsetを0に初期化して、デフォルトの動作がノートに0を加える（結果として何も変わらない）ようにします。 しかし、オペコードでstream_note_offsetに何らかの値を設定すると、ノートが変わります。 以下に、この動作を示すse_fetch_byteをアップデートします。<br><br><span style="font-family: Courier New">se_fetch_byte:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;...スニップ...</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;ノートに関することをする</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;インデックスをデータストリームに保存します。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">clc</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> adc stream_note_offset, x ;音符のオフセットを追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;データストリームのインデックスを復元する。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;...スニップ...</span><br><br>もしstream_note_offsetを2に設定したらどうなるか、想像してみてください。<br><br>1.C4ノートは16進数で#$1bと等価です(note_table.iのエイリアスを参照)。<br>2. この値にstream_note_offsetを加える。 #$1b + #$02 = #$1d.<br>3. 16進数値#$1dはD4音符に相当する(note_table.i参照)<br>4. なんと、一段上の音符になりました。<br><br>stream_note_offsetの値を同じにして、次のような音符の列があったとします。<br><br><span style="font-family: Courier New">C4, E4, G4, B4, C5, E5, G5, E5, B5, C6 ;Cmaj7</span><br style="font-family: Courier New"><br>と翻訳されるでしょう。<br><br style="font-family: Courier New"><span style="font-family: Courier New">D4, Fs4, A4, C#5, D5, Fs5, A5, C#6, D6 ;Dmaj7に変換されます。</span><br><br>stream_note_offset を使えば、音楽の一部分を簡単に他のキーに移調することができます。 前述のように、ストリームの stream_note_offset はゼロに初期化します。<br><br style="font-family: Courier New"><span style="font-family: Courier New">sound_load:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip---</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_OFFSET, X</span><br style="font-family: Courier New"><span style="font-family: Courier New">;---snip---</span><br><br><b>ノートオフセットの設定</b><br>では、stream_note_offsetに特定の値を設定するオペコードを作ってみましょう。<br><br><span style="font-family: Courier New">;-----------------------------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">これが私たちのJUMP TABLEです!</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_opcodes:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;$A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;$A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_duty ;$A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_set_loop1_counter ;$A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_loop1 ;$A5</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> ワードse_op_set_note_offset ;$A6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">サウンドデータで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">デューティ = $A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">set_loop1_counter = $A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ1 = $A5</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">セットノートオフセット = $A6</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_set_note_offset:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;引数の読み込み</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_offset, x ;音符のオフセットを設定する。</span><br><span style="font-family: Courier New"> rts</span><br><br>これで、データストリームの中でいつでもノートオフセットを設定できるようになりました。<br><br style="font-family: Courier New"><span style="font-family: Courier New">このように、データストリームの中でいつでも音符のオフセットを設定することができます。</span><br style="font-family: Courier New"><span style="font-family: Courier New">sound_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_note_offset, 2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C2, C3, C4, C5, ;etc. C調の音符を増やしました。</span><br><br><b>ノートオフセットの調整</b><br>ノートオフセットを特定の値に設定することは、非常に限定的な用途です。 それは、1回限りのキー変更のようなものです。 多くの場合、ノートオフセットをある相対的な値に設定したいと思うことでしょう。例えば、stream_note_offsetを2に設定する代わりに、stream_note_offsetを「現在のオフセット＋2」に設定したい場合があります。 stream_note_offsetを相対値で調整できるオペコードがあれば、ループと併用できます。 まず、オペコードを書いてみましょう。<br><br><span style="font-family: Courier New">;-----------------------------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">これが私たちのジャンプテーブルです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">サウンドコード:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;$A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;$A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_duty ;$A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_set_loop1_counter ;$A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_loop1 ;$A5</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ワードse_op_set_note_offset ;$A6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.word se_op_adjust_note_offset（ノートオフセット） ;$A7</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">これらは、サウンド・データで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">デューティ = $A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">set_loop1_counter = $A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ1 = $A5</span><br style="font-family: Courier New"><span style="font-family: Courier New">セットノートオフセット = $A6</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">アジャストノートオフセット = $A7</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_adjust_note_offset。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;引数を読む（どの値を足すか）。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_note_offset, x ;現在のオフセットに追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_offset, x ;そして保存する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>このオペコードの使い方を見てみましょう。 例えば、次のような長いアルペジオ行があるとします。<br><br><span style="font-family: Courier New">C2, E2, G2, B2, C3, E3, G3, B3, C4, E4, G4, B4, C5, E5, G5, B5, C6, E6, G6, B6, C7 ;Cmaj7 (21 bytes)のような長大なアルペジオがあるとします。</span><br><br>同じ4音（C E G B）を5オクターブにわたって繰り返すだけのパッセージです。<br><br><span style="font-family: Courier New">.byte set_loop1_counter, 5 ;5回ループする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C2, E2, G2, B2 ;ループさせる4音です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte adjust_note_offset, 12 ;反復ごとにオフセットに12を加える（つまり、1オクターブ上げる）。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop1 </span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C2 ;C7になる。Cmaj7 (12バイト)</span><br><br>ループの1回目はC2, E2, G2, B2、2回目はC3, E3, G3, B3、3回目はC4, E4, G4, B4, など。 オペコードを使って、データサイズを21バイトから12バイトに減らす。 ほぼ50%の節約になる。<br><br><b>バトル・キッド</b><br>もっと良い例として、バトルキッドのテーマ曲のベースラインを見てみましょう。 先週は、次のような感じでした。<br><br><span style="font-family: Courier New">song6_tri:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 第8</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, A3, A4, A4, A3, A3, A4, A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte G3, G3, G4, G4, G3, G3, G4, G4 ;down a step (-2)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte F3, F3, F4, F4, F3, F3, F4, F4 ;down a step (-2)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte Eb3, Eb3, Eb4, Eb4, Eb3, Eb3, Eb4, Eb4 ;down a step (-2)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード song6_tri</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 36バイト</span><br><br><span style="font-family: Verdana">X3、X3、X4、X4、X3、X3、X4、</span>X<span style="font-family: Verdana">4</span>、ここでXはある音です。 新しいXはそれぞれ前のXから2を引いたものです。新しいオペコードを使うと、ベースラインを次のように書き換えることができます。<br><br><span style="font-family: Courier New">song6_tri:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_loop1_counter, 4 ;4回繰り返す</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A3, A3, A4, A4, A3, A3, A4, A4 ;繰り返す一連の音符</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte adjust_note_offset, -2 ;一段下げる。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word .loop</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_note_offset, 0 ;4回繰り返した後、ノートオフセットを0にリセットする。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ.無限ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song6_tri </span><br style="font-family: Courier New"><span style="font-family: Courier New"> 21バイト</span><br><br>36バイトのROM領域が21バイトになり、約40%の節約になりました。<br><br><b>ルーピー効果音</b><br>ループとキーチェンジをハイテンポで組み合わせると、クールなサウンドエフェクトが得られます。 これを見てください（テンポは$FF）。<br><br style="font-family: Courier New"><span style="font-family: Courier New">song7_square2:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_loop1_counter, $08 ;8回繰り返す</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte thirtysecond, D7, D6, G6 ;異なるオクターブのD音2つとG音を演奏。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte adjust_note_offset, -4 ;2段階下がる。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte loop1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte endsound</span><br><br>この効果音は、単純な3音パターンを下降キーで超高速に再生します。 サウンドデータはわずか12バイトですが、かなり複雑な効果音になります。 今週のサンプルファイルのsong7を聞いてみてください。 このようにループを試すことで、手書きでは作曲が難しいような音も思いつくはずです。<br><br><b><font size="3">複雑なコード進行</font></b><br>バトル・キッドのベースラインは、割合的にはうまくいったと思う。 しかし、ラッキーなことに、コード進行は一貫したステップで下がっていく。-note_offsetを毎回同じ値（-2）だけ調整するので、これをループさせることができました。 しかし、もっと複雑な方法で繰り返されるパターンがあったとしたらどうでしょうか。 そうです。 Guardian Legendのボス曲のリズムパターンを見てみましょう。<br><br><span style="font-family: Courier New">song1_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A2, A2, A2, A3, A2, A3, A2, A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte F3, F3, F3, F4, F3, F4 ;+8 (A2 + 8 = F3)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A2, A2, A2, A3, A2, A3 ;-8</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte F3, F3, F3, F4, F3, F4 ;+8</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte E3, E3, E3, E4, E3, E4, E3, E4 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte E3, E3, E4, E3, E4, E3, E4 ;+0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte Ds3, Ds3, Ds4, Ds3, Ds4, Ds3, Ds4 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte D3, D3, D4, D3, D4, D3, D4 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte C3, C3, C3, C4, C3, C4 ;-2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte B2, B2, B3, B2, B3, B2, B3 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte As2, As2, As2, As3, As2, As3, As2, As3 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A2, A2, A2, A3, A2, A3 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte Gs2, Gs2, Gs2, Gs3, Gs2, Gs3, Gs2, Gs3 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte G2, G2, G2, G3, G2, G3, G2, G3 ;-1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ;+2 (A2へループバック)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード song1_square1</span><br><br>ここで、もう一つのパターンがある。Xi, Xi, Xi, Xi+1, Xi, Xi+1, Xi, Xi+1。 Xは音符、iはオクターブ。 パターンがあるということは、ループによってバイトを節約できるチャンスだ。 しかし、バトルキッドと違って、このパターンは一貫性がなく飛び回る。 どうすればいいのか?<br><br><b>スーパーTGLの転調トリック</b><br>このトリックは、守護神伝説から学んだので、<b>TGL Transp</b>osition Trickと呼んでいる。 パターンをループさせ、そのループカウンターをインデックスとして、ルックアップテーブルを作成する。 ルックアップテーブルは、ノートオフセット値を含む。 ループカウンターはデクリメントするので、ルックアップテーブルは順次後ろに下がっていくことになる。<br><br>では、この例を見てみましょう。<br><br><span style="font-family: Courier New">song1_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_loop1_counter, 14 ;14回繰り返す</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A2、A2、A2、A3、A2、A3、A2、A3</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">;lookup_tableから値を取り出して</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> stream_note_offset に追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ1有限ループ(14回)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ.無限ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード song1_square1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.lookup_table。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 2, -1, -1, -1, -1, -2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte -1, -1, 0, -1, 8, -8, 8 ;14エントリ長、逆順。</span><br><br>ここでちょっと分解してみますが、まず、上の赤で示した部分は、transposeという1つのオペコードでカバーされます。 transposeオペコードは2バイトの引数を取るので、そのコメント部分を全部合わせて3バイトのデータに置き換わります。つまり、リズム音データのバイト数を全部足すと34バイトになります。 オリジナルは116バイトですが、TGLのトランスポーズ・トリックを使うと82バイトになります。 これは70％もの節約です。<br><br><span style="font-family: Courier New">song1_square1:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte set_loop1_counter, 14 ;14回繰り返す。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.loop:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte A2, A2, A2, A3, A2, A3, A2, A3</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">.バイト transposeトランスポーズのオペコードは2バイトの引数を取る。</span></span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.word .lookup_table ;ルックアップテーブルのアドレスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ1;有限ループ(14回)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード .ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイトループ.無限ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード song1_square1</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">.lookup_table。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 2, -1, -1, -1, -1, -2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte -1, -1, 0, -1, 8, -8, 8 ;14エントリ長、逆順。</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">;*** 全体で34バイト ***。</span><br><br>転置オペコードはルックアップテーブルを指すポインタ変数をセットアップします。 そして、ループカウンタを取って1を引き、その結果をテーブルのインデックスとして使用します。 1を引くのはテーブルのインデックスがゼロから始まるからです。 14回ループすると、テーブルには0から13までの14個のエントリがあります。 転置オペコードはそのインデックスを持ってから、テーブルから値を取得します。 この値は stream_note_offset に加算されます。<br><br>オペコードを書く前に、それがどのように動作するかを見るためにデータをトレースしてみましょう。 song1_square1 の最初のバイトから始めます。<br><br>1) 音符の長さを8分音符に設定<br>2) ループカウンターを14にセット<br><br>(.loop iteration 1)<br>3) 一連の音符を演奏する。A2, A2, A2, A3, A2, A3, A2, A3<br>4) オペコードをトランスポーズする。 lookup_tableへのポインタをセットアップする。 ループカウンタから1を引いたものをインデックスとして使う。 ループカウンタは現在14なので、.lookup_table+13を引き出す。これは8だ。現在のstream_note_offsetに8を加える。0 + 8 = 8.<br>5) ループカウンターをデクリメントし (14-&gt;13) 、.loop ラベルにループバックする<br><br>(反復2)<br>6) 新しい音列を+8で表示： F3, F3, F3, F4, F3, F4, F3, F4. <br>7) 転置オペコード。 ループカウンタは13。 .lookup_table+12で-8。 stream_note_offsetに-8を加える：8 + -8 = 0。<br>8) ループカウンターをデクリメントし (13-&gt;12) .loop ラベルにループバックする。<br><br>(繰り返し3)<br>9) +0を使った新しい音符の列：A2, A2, A2, A3, A2, A3, A2, A3 <br>10) 転置オペコード。 ループカウンタは12。 .lookup_table+11で8。 stream_note_offsetに8を足す。<br>11) ループカウンタをデクリメントし (12-&gt;11) .loop ラベルにループバックする。<br><br>(繰り返し4)<br>12) +8を加えた新しい音列：F3, F3, F3, F4, F3, F4, F3, F4.F3, F4.F4. <br>13) 転置オペコード。 ループカウンタは11。 .lookup_table+10で-1。 stream_note_offsetに-1を追加：8 + -1 = 7。<br>14) ループカウンタをデクリメントし (11-&gt;10)、.loopラベルにループバックする。<br><br>(繰り返し4)<br>15) +7を含む新しい音列： E3, E3, E3, E4, E3, E4, E3, E4. <br>16) 転置オペコード。 ループカウンタは10。 .lookup_table+9を取得して0。 stream_note_offsetに0を追加：7 + 0 = 7。<br>17) ループカウンターをデクリメントし (10-&gt;9) 、.loop labelにループバックする。<br><br>最後の繰り返しでループカウンターは1になる。 .lookup_table+0を取得し、stream_note_offsetに追加する。 そして、ループカウンターをデクリメントする（1-&gt;0）。 ループカウンターが0になり、ループが切れる。 なかなかクールでしょう？ 書いてみましょう。<br><br><span style="font-family: Courier New">;-----------------------------------------------------------------------</span><br style="font-family: Courier New"><span style="font-family: Courier New">これが私たちのジャンプテーブルです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.サウンド_OPコード:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_endsound ;$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_infinite_loop ;$A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_change_ve ;$A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_duty ;$A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_set_loop1_counter ;$A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word se_op_loop1 ;$A5</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ワードse_op_set_note_offset ;$A6</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ワード SE_OP_ADJUST_NOTE_OFFSET ;$A7</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.word se_op_transpose ;$A8</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">;これらはサウンド・データで使用するエイリアスです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">エンドサウンド = $A0</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ = $A1</span><br style="font-family: Courier New"><span style="font-family: Courier New">ボリューム・エンベロープ = $A2</span><br style="font-family: Courier New"><span style="font-family: Courier New">デューティ = $A3</span><br style="font-family: Courier New"><span style="font-family: Courier New">set_loop1_counter = $A4</span><br style="font-family: Courier New"><span style="font-family: Courier New">ループ1 = $A5</span><br style="font-family: Courier New"><span style="font-family: Courier New">セットノートオフセット = $A6</span><br style="font-family: Courier New"><span style="font-family: Courier New">アジャストノートオフセット = $A7</span><br style="font-family: Courier New"><span style="font-family: Courier New; color: rgb(255, 0, 0)">トランスポーズ = $A8</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">se_op_transpose:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;ルックアップテーブルへのポインタの下位バイトを読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta<span style="color: rgb(255, 0, 0)">sound_ptr2</span>;それを新しいポインタ変数に格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y ;テーブルへのポインタの上位バイトを読み込む</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta<span style="color: rgb(255, 0, 0)">sound_ptr2+1</span></span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp ;これから破壊するのでyを保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda stream_loop1, x ;ループカウンタを取得し、Yに格納する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tayこれはルックアップテーブルのインデックスになる</span><br style="font-family: Courier New"><span style="font-family: Courier New"> deyインデックスが0から始まるので、1を引く。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [<span style="color: rgb(255, 0, 0)">sound_ptr2</span>], y ;テーブルから値を読み込む。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_note_offset, x ;これをノートオフセットに加える。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_offset, x ;音符のオフセットに加える。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp ;Yを復元する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>ここで、新しいポインタ変数sound_ptr2があります。 実は、jmp_ptrをsound_ptr2に改名しました。 この新しい名前は、サウンドエンジン用であることを示しています。 jmp_ptrはジャンプするとすぐに終了するので、ここでポインタ衝突が起こることはありません。<br><br><b>まとめ</b><br>これは、オペコードとループの賢い使い方で、いかに多くのバイトを節約できるかの一例です。 このトランスポーズのオペコードは、リズムセクションに繰り返しのパターンがある音楽を書く場合のみ有効であることに注意してください。 そうでない場合は、バイトを節約してサウンドエンジンからこのオペコードをカットしてください。<br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/opcodes2.zip" target="_blank" original-href="http://tummaigames.com/opcodes2.zip">opcodes2.zip</a>のサンプルファイルをダウンロードして解凍します。 以下のファイルが NESASM3 と同じフォルダにあることを確認してください。<br><br>opcodes2.asm<br>sound_engine.asm<br>sound_opcodes.asm<br>opcodes2.chr<br>note_table.i<br>ノート長テーブル.i<br>vol_envelopes.i<br>song0.i<br>song1.i<br>曲2.i<br>曲3.i<br>song4.i<br>ソング5.i<br>ソング6.i<br>ソング7.i<br>opcodes2.bat<br><br>opcodes2.batをダブルクリックします。NESASM3が実行され、opcodes2.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラーで曲を選んでプレイします。 操作方法は以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>：次の曲／SFX<br><b>左</b>：前の曲/SFX<br><br>Song0は無音曲で、選択できません。<br>Song1〜Song6は先週と同じですが、ROMの容量が少なくなりました。<br>Song7は、キーチェンジをハイテンポでループさせた、新しい効果音です。<br><br>いつものように、新しいオペコードを使って、自分の好きな曲や効果音を入れてみてください。 実験してみてください。<br><br><b>次週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=27943" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=27943">ノイズ、シンプルドラム</a><br>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-9__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="audio_tutorial-10">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">オタクな夜の音。第10回：シンプルなドラム</h2>
      </div>
      <div class="mdl-card__supporting-text">
       <b>先週</b>：<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247" target="_blank" original-href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=26247">有限ループ、キー・チェンジ、コード・プログレッション</a><br><b><br>
         </b><b>今週は</b>シンプルなドラム<br><br><font size="5"><b>ドラム</b></font><br>今週は、ドラムを取り上げます。 このドラムは、他の3つのチャンネルとは動作が大きく異なる<b>Noise</b>チャンネルを使用するため、今まで保存していました。 SquareとTriangleチャンネルでは、波形の周期を手動で設定して、演奏する音を選択します。 ノートルックアップテーブルは、チャンネルポートに差し込む周期表だけです。 一方、Noiseチャンネルはランダムノイズを生成します。 ノートテーブルは全く使用しません。<br><br><font size="3"><b>ノイズチャンネル</b></font><br>ノイズ・チャンネルは音符を出さず、ノイズを出します。 ノイズ・チャンネルとは、3つのポートで通信します。400<b>C</b>、<b>400E</b>、<b>400F</b>です。 400Dは<i>未使用</i>です。 ノイズチャンネルのポートを詳しく見てみましょう。<br><br><b>ボリューム - $400C</b><br>400Cは、ノイズ・チャンネルのボリュームを制御します。 デューティ・サイクルがないことを除けば、スクエア・チャンネルと同じように機能します。<br><br><span style="font-family: Courier New">Noi_Env ($400C)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ||||||</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ||++++- ボリューム</span><br style="font-family: Courier New"><span style="font-family: Courier New"> |+----- Saw Envelope Disable (0: 音量に内部カウンタを使用; 1: 音量にボリュームを使用)</span><br style="font-family: Courier New"><span style="font-family: Courier New"> +------ 長さカウンタ無効 (0: 長さカウンタを使用; 1: 長さカウンタを無効)</span><br><br>ノコギリエンベロープを無効にし、長さカウンターを無効にします。 これにより、ボリュームエンベロープでノートの長さと音量を完全にコントロールすることができます。 Squareチャンネルも同じようにします。<br><br><b>ランダム・ジェネレーター - $400E</b><br>400Eはランダムジェネレータの設定をコントロールします。 以下のような感じです。<br><br><span style="font-family: Courier New">Noi_rand ($400E)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New"></span><br style="font-family: Courier New"><span style="font-family: Courier New">| ++++- サウンドタイプ</span><br style="font-family: Courier New"><span style="font-family: Courier New">+-------- モード</span><br><br><b>Modeは</b>モードを設定します。<b>Mode-0と</b> <b>Mode-1の</b>2つのモードがあります。 Mode-0は静的なssshのような鈍く息苦しい音です。 Mode-1はよりシャープでロボット的でざわついた音です。 本当に言葉で表すのは難しいので、音の違いを知るには、両方のモードを聴くのが一番です。（下図参照）。<br><br>それぞれのモードには、<b>サウンドタイプで</b>選択された16のサウンドがあります。 つまり、Noiseチャンネルでは、合計32のサウンドしか得られないのです！Noiseチャンネルでより複雑なサウンド効果を得るには、この32のサウンドを次々に組み合わせて再生します。 32のサウンドがそれぞれどんなサウンドなのか、今週のサンプルプログラムの<b>ソング8を聞いてみて</b>ください。 モード0のサウンド16と、モード1のサウンド16が続いて再生されています。<br><br>注：このチュートリアルでは、32のNoiseチャンネルの音にそれぞれ00〜1Fの番号を割り当てます。 左の番号（0または1）は<i>モードを</i>、右の番号（0〜F）は<i>サウンド</i>タイプを意味します。 例えば、音「04」は「モード0、サウンドタイプ4」、音「1E」は「モード1、サウンドタイプE」という意味です。<br><br><b>長さカウンタ - $400F</b><br>400Fは、Noiseチャンネルの長さカウンタです。 長さカウンタは、400Cで無効にしたので、このポートは完全に無視してもかまいません<br><font size="3"><b><br>
            Simple Noise Drums<br> </b></font><br>Noiseチャンネルでドラムサウンドを作る最もシンプルな方法は、0（無音）に向かって減衰するボリュームエンベロープの下で1つのサウンドタイプを再生することです。 多くのゲームはこの種のドラムのみを使用しています。 例えば、The Guardian Legendではゲーム全体で2つのドラムサウンドのみを使用します。バトルキッドも、このシンプルなドラムを多用しています。 多くのゲームで使われています。<br><br>では、シンプルなドラムをどのようにサウンドデータで表現するかというと、サウンドエンジンがノート、ノートレングス、オペコードを範囲指定で区別していることを思い出してください。<br><br><span style="font-family: Courier New">.fetch:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda [sound_ptr], y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bpl .note ;if &lt; #$80, それはノートです。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> cmp #$A0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .note_length ;else if &lt; #$A0, it's a Note Length</span><br style="font-family: Courier New"><span style="font-family: Courier New">.opcode: ;else それはオペコードです。</span><br style="font-family: Courier New"><span style="font-family: Courier New">;do opcode stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New">;<span style="color: rgb(255, 0, 0)">範囲 A0-FF</span></span><br style="font-family: Courier New"><span style="font-family: Courier New">.note_length:</span><br style="font-family: Courier New"><span style="font-family: Courier New">;音符の長さを指定する</span><br style="font-family: Courier New"><span style="font-family: Courier New">;範囲<span style="color: rgb(255, 0, 0)">80-9F</span></span><br style="font-family: Courier New"><span style="font-family: Courier New">.音符</span><br style="font-family: Courier New"><span style="font-family: Courier New"> 音符を鳴らす</span><br style="font-family: Courier New"><span style="font-family: Courier New"><span style="color: rgb(255, 0, 0)">範囲 00-7F</span></span><br><br>Noiseチャンネルではノートテーブルを使いませんが、ドラムは音符と同じように扱います。 ですから、ドラムデータの値は$00-$7Fの範囲にする必要があります。 簡単ですね。 Mode-0の音は$00-$0Fに、Mode-1の音は$10-$1Fに割り当てます。 すると、ドラムデータはこんな風になりますね。<br><br><span style="font-family: Courier New">example_drum_data:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト8分音符, $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 16th, $1E, $1E, $1F</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト d_eighth, $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 16番目、$06、$06、$08、$08</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト8番目、$17、$07</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード example_drum_data</span><br><br><br>Noiseではノートテーブルを使用しないので、Noteのコードを変更してチャンネルをチェックし、Noiseチャンネルを処理する場合は別のコードに分岐する必要があります（赤色の新しい部分）。<br><br><span style="font-family: Courier New">.note:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.note: ;do Note stuff</span><br style="font-family: Courier New"><span style="font-family: Courier New"> <span style="color: rgb(255, 0, 0)">sta sound_temp2 ;ノート値を保存</span>する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda stream_channel, x ;どのチャンネルを使用しているか？</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> cmp #NOISE ;Noiseチャンネルか？</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> bne .not_noise </span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jsr se_do_noise ;そうであれば、ノイズデータを扱うサブルーチンにJSRする</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> jmp .reset_ve ;そして、戻るときにノートテーブルをスキップする。</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)">.not_noise: ;さもなければ音符テーブルからピリオドを取得する</span><br style="font-family: Courier New; color: rgb(255, 0, 0)"><span style="font-family: Courier New; color: rgb(255, 0, 0)"> lda sound_temp2 ;音符の値を復元する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sty sound_temp1 ;インデックスをデータストリームに保存する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_note_offset, x ;音符のオフセットを追加する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> asl a</span><br style="font-family: Courier New"><span style="font-family: Courier New"> テイ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda note_table+1, y</span><br style="font-family: Courier New"><span style="font-family: Courier New"> STA STREAM_NOTE_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ldy sound_temp1 ;データストリームのインデックスを復元する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New"> レストであるかどうかをチェックし、ステータスフラグを適切に変更する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> jsr se_check_rest</span><br style="font-family: Courier New"><span style="font-family: Courier New"><span style="color: rgb(255, 0, 0)">.reset_ve</span>: </span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA #$00</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ve_index, x </span><br style="font-family: Courier New"><span style="font-family: Courier New">.update_pointer:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> iny</span><br style="font-family: Courier New"><span style="font-family: Courier New"> tya</span><br style="font-family: Courier New"><span style="font-family: Courier New"> clc</span><br style="font-family: Courier New"><span style="font-family: Courier New"> adc stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_ptr_LO, x</span><br style="font-family: Courier New"><span style="font-family: Courier New"> bcc .end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> inc ストリーム_ptr_HI, x</span><br style="font-family: Courier New"><span style="font-family: Courier New">.end</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>このコードはチャンネルがNoiseチャンネルかどうかをチェックします。 Noiseチャンネルであれば、特別なNoiseサブルーチンにJSRします。 戻り次第、note_tableコードを飛び越え、通常のようにボリュームエンベロープとストリームポインタを更新します。<br><br><span style="font-family: Courier New">se</span> <span style="font-family: Courier New">_do_</span>noiseの仕事は、音符の値を受け取って、それを400E（NOI_RAND）に書き込めるように変換することです。 400Eは、ビット7にモード番号、ビット0-3にサウンドタイプを要求していることを思い出してください。<br><br style="font-family: Courier New"><span style="font-family: Courier New">NOI_RAND ($400E)</span><br style="font-family: Courier New"><br style="font-family: Courier New"><span style="font-family: Courier New">76543210</span><br style="font-family: Courier New"><span style="font-family: Courier New">| ||||</span><br style="font-family: Courier New"><span style="font-family: Courier New">| ++++- 音の種類</span><br style="font-family: Courier New"><span style="font-family: Courier New">+-------- モード</span><br><br>モード<b>0の</b>音は全く変換する必要がなく、$00-$0Fの値で表し、これは$400Eに書き込むべき値に正確に対応します。<br><br>モード<b>1の</b>音は、$10-$1F、つまり2進数の%00010000-%00011111で表現します。 モード番号をビット4で識別していることに注意してください。 しかし、ポート400Eはモード番号をビット4ではなく、ビット7で期待しているので、ビット7を自分で設定する必要があります。<br><br><span style="font-family: Courier New">SE_DO_NOISE:</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOUND_TEMP2 ;音符の値を復元する。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> と#%00010000 ;ビット4を切り離す</span><br style="font-family: Courier New"><span style="font-family: Courier New"> beq .mode0 ;クリアならMode-0なので無変換</span><br style="font-family: Courier New"><span style="font-family: Courier New">.mode1。</span><br style="font-family: Courier New"><span style="font-family: Courier New"> lda sound_temp2 ;それ以外はMode-1、音価を元に戻す</span><br style="font-family: Courier New"><span style="font-family: Courier New"> ora #%10000000 ;ビット7をセットしてMode-1を設定する</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta sound_temp2</span><br style="font-family: Courier New"><span style="font-family: Courier New">.mode0</span><br style="font-family: Courier New"><span style="font-family: Courier New"> LDA SOUND_TEMP2</span><br style="font-family: Courier New"><span style="font-family: Courier New"> sta stream_note_LO, x ;400Eにコピーされるテンポラリポート</span><br style="font-family: Courier New"><span style="font-family: Courier New"> rts</span><br><br>これで設定完了です。 $00-$0Fの音符は直接<span style="font-family: Courier New">stream_note_LOに</span>書き込まれます。 $10-$1F の音符はまず$90-$9Fに変換されてから<span style="font-family: Courier New">stream_note_LOに</span>書き込まれます。 なお、モード1の音に関してはbit4をクリアする必要はありません。 bit4は$400Eに対して何もしないのでそのままでもよいでしょう。<br><br><font size="3"><b>ドラムの減衰</b></font><br>あとは、シンプルなドラムのためのボリューム・エンベロープを追加するだけです。 これは短く、ゼロ（無音）まで減衰する必要があります。<br><br>ボリュームエンベロープ:<br>.ワード se_ve_1<br>.ワード se_ve_2<br>.word se_ve_3<br>.ワード se_ve_tgl_1<br>.単語se_ve_tgl_2<br>.単語 se_battlekid_loud<br>.ワード se_battlekid_loud_long<br>.単語 se_battlekid_soft<br>.単語 se_battlekid_soft_long<br>.ワード<span style="color: rgb(255, 0, 0)"> se_drum_decay</span><br><br><span style="color: rgb(255, 0, 0)">se_drum_decay:</span><br style="color: rgb(255, 0, 0)"><span style="color: rgb(255, 0, 0)">.byte $0E, $09, $08, $06, $04, $03, $02, $01, $00 ;ドラム1個につき7フレーム。</span><br style="color: rgb(255, 0, 0)"><span style="color: rgb(255, 0, 0)">.byte $FF</span><br><br><span style="color: rgb(255, 0, 0)">VE_DRAM_DECAY = $09</span><br style="color: rgb(255, 0, 0)"><br>もちろん、ドラムのボリュームエンベロープを複数作って、そこから選択することもできます。<br><br><font size="3"><b>まとめ</b></font><br><br>これで、曲にドラムデータを追加できるようになりました。 ここでは、これまで使ってきたThe Guardian Legendのボス曲のドラムデータを使ってみます。<br><br><span style="font-family: Courier New">ソングヘッダの、SquaresとTriangleのヘッダ情報の後です。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte MUSIC_NOI ;どのストリームか。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $01 ;ステータスバイト: 有効</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte NOISE ;どのチャンネルか。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $30 ;volume_dutyの初期値(長さカウンタと鋸歯状エンベロープを無効にする)</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte ve_drum_decay ;ボリューム・エンベロープ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.word song1_noise ;サウンドデータストリームへのポインタ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte $53 ;テンポ</span><br style="font-family: Courier New"><span style="font-family: Courier New"> </span><br style="font-family: Courier New"><span style="font-family: Courier New">song1_noise:</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte eighth, $04 ;この曲では、ドラム04（Mode-0, Sound Type 4）をスネアとしてのみ使用します。</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte sixteenth, $04, $04, $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte d_eighth, $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.byte 16th, $04, $04, $04, $04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト8分目、$04、$04</span><br style="font-family: Courier New"><span style="font-family: Courier New">.バイト ループ</span><br style="font-family: Courier New"><span style="font-family: Courier New">.ワード song1_noise</span><br><br>自分の曲にドラムを追加してみよう<br><br><b>すべてをまとめる</b><br><a href="downloads/NerdyNightsSoundSourceCollection/drums.zip" target="_blank" original-href="http://tummaigames.com/drums.zip">drums.zip</a>のサンプルファイルをダウンロードして解凍します。 以下のファイルが NESASM3 と同じフォルダにあることを確認してください。<br><br>drums.asm<br>サウンドエンジン(sound_engine.asm)<br>サウンドコード(sound_opcodes.asm)<br>drums.chr<br>note_table.i<br>note_length_table.i（ノート長さ<br>vol_envelopes.i<br>song0.i<br>song1.i<br>曲2.i<br>曲3.i<br>song4.i<br>ソング5.i<br>ソング6.i<br>ソング7.i<br>曲8.i<br>drums.bat<br><br>drums.batをダブルクリックします。NESASM3が実行され、drums.nesファイルが生成されるはずです。そのNESファイルをFCEUXD SPで実行します。<br><br>コントローラで曲を選んで演奏します。 コントロールは以下の通りです。<br><br><b>上へ</b>再生<br><b>下</b>：停止 <br><b>右</b>：次の曲／SFX<br><b>左</b>：前の曲/SFX<br><br><b>Song0は</b>無音曲です。 選択できません。<br><b>Song1〜Song7は</b>先週と同じですが、そのうちのいくつか（1、4、6）にはドラムが入るようになりました。<br><b style="color: rgb(255, 0, 0)">Song8は</b>、Noiseチャンネルの32個の音を00〜1Fの順に再生する新しい "曲 "だ。 まず、持続的なボリューム・エンベロープで再生するので、引き伸ばされた音が聴ける。 次に、7フレームのve_drum_decayボリューム・エンベロープで再生するので、単純なドラム音として聴くことができる。<br><br><b>次週は</b>より複雑なドラム音、ノイズSFX      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="#audio_tutorial-toc" data-upgraded=",MaterialButton,MaterialRipple">
          目次へ移動         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>
        <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect" href="javascript:doCommentToggle('audio_tutorial-10__comments');" data-upgraded=",MaterialButton,MaterialRipple">
          トグルコメント         <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a>

        <div style="float: right">
          
           <a class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent" href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=27943" target="_blank" data-upgraded=",MaterialButton,MaterialRipple">元記事<span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></a></div>
      </div>
    </div>
  </body>
</html>
