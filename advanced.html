<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
  </head>
  <body>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="advanced_tutorial-0">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">Advanced Nerdy Nights #1: CHR Bank switching</h2>
      </div>
      <div class="mdl-card__supporting-text">
        <span class="Apple-style-span" style="font-weight: bold"
          ><div>
            <span class="Apple-style-span" style="font-weight: normal"
              >To do the advanced lessons you should have already finished Pong.</span
            >
          </div>
          <div><br /></div>
          This Week:&nbsp;</span
        >As you complete a full game you may find the NROM memory limits to be too small. To enable more
        ROM on carts many forms of "bank switching" were used. This article deals with just one type of
        CHR switching, used on CNROM carts. CNROM is easy to use and very cheap to manufacture. The
        <a
          href="https://www.retrousb.com/product_info.php?ref=5&amp;products_id=42&amp;affiliate_banner_id=1"
          target="_blank"
          original-href="http://www.retrousb.com/product_info.php?ref=5&amp;products_id=42&amp;affiliate_banner_id=1"
          >ReproPak</a
        >,
        <a
          href="https://www.retrousb.com/product_info.php?ref=5&amp;products_id=34&amp;affiliate_banner_id=1"
          target="_blank"
          original-href="http://www.retrousb.com/product_info.php?ref=5&amp;products_id=34&amp;affiliate_banner_id=1"
          >PowerPak</a
        >, and
        <a
          href="https://www.retrousb.com/product_info.php?ref=5&amp;products_id=35&amp;affiliate_banner_id=1"
          target="_blank"
          original-href="http://www.retrousb.com/product_info.php?ref=5&amp;products_id=35&amp;affiliate_banner_id=1"
          >PowerPak Lite</a
        >
        all support CNROM completely so it is easy to get your code running on real hardware. If you are
        using donor carts you can look up games that use CNROM at
        <a
          href="http://bootgod.dyndns.org:7777/"
          target="_blank"
          original-href="http://bootgod.dyndns.org:7777/"
          >BootGod's NES Cart Database</a
        >.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"> CHR Bank Switching</span> </span
        ><br />
        Bank switching is exchanging one chunk of ROM for a different chunk, while keeping everything in
        same address range. It is not making a copy, so it happens instantly. You can switch between
        different banks whenever you want. The size and memory range of the banks depends on the mapper.
        For the CNROM mapper used in this article the bank size is 8KB of CHR ROM. The whole 8KB range of
        PPU memory $0000-1FFF is switched at once. This means the graphics for all background tiles and
        sprite tiles will be swapped. In your game you may have some tiles duplicated in multiple banks
        so they do not appear to change on screen. PRG is not bank switched, so it remains at the NROM
        limit of 32KB.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"> Set Mapper Number</span></span
        ><br />
        The first part of adding bank switching is changing the mapper number your .NES file uses. At the
        top of your code has previously been:<br />
        <br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px"
            >&nbsp;&nbsp;.inesmap 0 ; mapper 0 = NROM, no bank swapping</span
          >
        </p>
        <br />
        The new line is:<br />
        <p></p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px"
            >&nbsp;&nbsp;.inesmap 3 ; mapper 3 = CNROM, 8KB CHR ROM bank swapping</span
          >
        </p>
        <br />
        This line in the header just tells the emulator to use CNROM to play your game. A list of other
        iNES mapper numbers can be seen at the wiki at
        <a href="http://nesdevwiki.org/" target="_blank" original-href="http://nesdevwiki.org/"
          >http://nesdevwiki.org/...</a
        >. <br />
        <br />
        <br /><span class="Apple-style-span" style="font-size: medium"
          ><span class="Apple-style-span" style="font-weight: bold"> Set CHR Size</span></span
        ><br />
        The next part is to increase the size of your CHR ROM. Change the .ineschr value from 1 to 2,
        showing that there are now two 8KB banks. CNROM can handle 32KB of CHR ROM or four 8KB banks but
        this example will only use two.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"> Add CHR Data</span></span
        ><br />
        The third part adds the data for the next bank into your game. Just make a new .bank statement
        below your current one for CHR, giving it the next sequential number. In your code when you set
        which bank to switch to this is the number used. PRG bank numbers are ignored so your original
        CHR bank will be #0 and the new one will be #1.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"> Bank Switching Code</span></span
        ><br />
        The final part it to write your bank switching code. This subroutine will take a bank number in
        the A register and switch the CHR bank to it immediately. The actual switch is done by writing
        the desired bank number anywhere in the $8000-FFFF memory range. The cart hardware sees this
        write and changes the CHR bank.<br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span class="Apple-style-span" style="font-family: '-webkit-sans-serif'; font-size: 12px"
            ><br
          /></span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">... your game code ...</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px"
            >&nbsp;&nbsp;LDA #$01 ;;put new bank to use into the A register</span
          >
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px"
            >&nbsp;&nbsp;JSR Bankswitch ;;jump to bank switching code</span
          >
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">... your game code ...</span>
        </p>
        <br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">Bankswitch:</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;STA $8000 ;;new bank to use</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;RTS</span>
        </p>
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"> Bus Conflicts</span></span
        ><br />
        When you start running your code on real hardware there is one catch to worry about. For basic
        mappers, the PRG ROM does not care if it receives a read or a write command. It will respond to
        both like a read by putting the data on the data bus. This is a problem for bank switching, where
        the CPU is also trying to put data on the data bus at the same time. They electrically fit in a
        "bus conflict". The CPU could win, giving you the right value. Or the ROM could win, giving you
        the wrong value. This is solved by having the ROM and CPU put the same value on the data bus, so
        there is no conflict. First a table of bank numbers is made, and the value from that table is
        written to do the bank switch.<br />
        <br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">... code ...</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;LDA #$01 ;;put new bank to use into A</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px"
            >&nbsp;&nbsp;JSR Bankswitch ;;jump to bank switching code</span
          >
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">... code ...</span>
        </p>
        <br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">Bankswitch:</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;TAX ;;copy A into X</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;STA Bankvalues, X ;;new bank to use</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;RTS</span>
        </p>
        <br />
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">Bankvalues:</span>
        </p>
        <p
          style="
            margin-top: 0px;
            margin-right: 0px;
            margin-bottom: 0px;
            margin-left: 0px;
            font: normal normal normal 10px / normal Monaco;
          "
        >
          <span style="letter-spacing: 0px">&nbsp;&nbsp;.db $00, $01, $02, $03 ;;bank numbers </span>
        </p>

        <br />
        The X register is used as an index into the Bankvalues table, so the value written by the CPU
        will match the value coming from the ROM.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-weight: bold"
          ><span class="Apple-style-span" style="font-size: medium"
            ><br />
            Putting It All Together</span
          ></span
        ><br />
        Download and unzip the
        <a
          href="scraper/files/chrbanks.zip"
          target="_blank"
          original-href="http://www.nespowerpak.com/nesasm/chrbanks.zip"
          >chrbanks.zip</a
        >
        sample files. This set is based on the previous
        <a
          href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=7974"
          target="_blank"
          original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=7974"
          >Week 5</a
        >
        code. Make sure that file, mario0.chr, mario1.chr, and chrbanks.bat is in the same folder as
        NESASM3, then double click on chrbanks.bat. That will run NESASM3 and should produce
        chrbanks.nes. Run that NES file in FCEUXD SP to see small Mario.<br />
        <br />
        Inside the LatchController subroutine a new section is added to read the Select and Start buttons
        from the controller. The Select button switches to CHR bank 0, and the Start button switches to
        CHR bank 1. Graphics of CHR bank 1 have been rearranged so Mario will change to a beetle.
        &nbsp;The tile numbers are not changed, but the graphics for those tiles are.
        <div><br /></div>
        <div>
          Open the PPU Viewer from the Tools menu in FCEUXD SP and try hitting the buttons. &nbsp;You can
          see all the graphics changing at once when the active bank switches.
        </div>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="#advanced_tutorial-toc"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Back to Table of Contents
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="javascript:doCommentToggle('advanced_tutorial-0__comments');"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Toggle Comments
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <div style="float: right">
          <a
            class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent"
            href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=17074"
            target="_blank"
            data-upgraded=",MaterialButton,MaterialRipple"
          >
            Original Article
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
          ></a>
        </div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="advanced_tutorial-1">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">
          Advanced Nerdy Nights #2: MMC1 CHR and PRG Bank switching, WRAM + Battery
        </h2>
      </div>
      <div class="mdl-card__supporting-text">
        <b>This Week:</b> The MMC1 is the first advanced mapper made by Nintendo. It is used for many
        games including top titles like The Legend of Zelda. The main benefits are mirroring control, up
        to 256KB of PRG ROM, 128KB of CHR RAM or ROM, and 8KB of WRAM. The WRAM can be battery backed for
        saved games. This tutorial will cover all features of the MMC1 and how to use them. You should be
        comfortable with the normal Nerdy Nights series before starting. &nbsp;Another more simple lesson
        for bankswitching is&nbsp;<a
          href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=17074"
          target="_blank"
          original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=17074"
          >Advanced Nerdy Nights #1</a
        >.&nbsp;&nbsp;If you only need one or two of the banking features then you may want to consider
        more simple and cheaper mappers instead such as UNROM or CNROM.<br />
        <br />
        Carts using the MMC1 will have the S*ROM board code, like SNROM and SGROM. BootGod's
        <a
          href="http://bootgod.dyndns.org:7777/"
          target="_blank"
          original-href="http://bootgod.dyndns.org:7777/"
          >NesCartDB</a
        >
        database can be searched for which games use which boards. The
        <a
          href="https://www.retrousb.com/product_info.php?cPath=24&amp;products_id=43"
          target="_blank"
          original-href="http://www.retrousb.com/product_info.php?cPath=24&amp;products_id=43"
          >ReproPak MMC1</a
        >
        board can also be used to build carts.
        <br />
        <br /><br /><span class="Apple-style-span" style="font-size: medium"
          ><b> Shift Registers</b></span
        ><br />
        The MMC1 uses a 5 bit shift register to temporarily store the banking bits. Shift registers were
        covered in
        <a
          href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=8747"
          target="_blank"
          original-href="http://www.nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=8747"
          >Week 7</a
        >. When writing to the register data comes in from data bit 0 only. This is similar to the
        controller reading where data outputs to data bit 0. Every time a write happens the current bits
        are shifted and D0 is inserted. The first bit you write eventually becomes to lowest bank bit. On
        the 5th write when the shift register is full the 5 bit value gets copied to the banking
        register. At this point the bank switch happens immediately without any delays. To load a bank
        register the LSR instruction is used for shifting:<br />
        <pre>
  LDA banknumber
STA bankreg    ; load bank bit 0 to shift register from data bit 0
LSR A          ; shift in next data bit to position 0
STA bankreg    ; load bank bit 1 from data bit 0
LSR A
STA bankreg    ; bank bit 2
LSR A
STA bankreg    ; bank bit 3
LSR A
STA bankreg    ; bank bit 4, bank register loaded, bank switch happens here</pre
        >
        <br />
        Unlike other simple mappers like UNROM and CNROM, there are no bus conflicts. The ROM is not
        enabled while you are writing so you do not have to make the data you are writing match.<br />
        <br />
        Data bit 7 is also connected to the MMC1. When a write happens to any banking register with D7=1
        the shift register is reset back to position 0. It will then take another 5 writes to fully load
        the next value. All other bits are ignored and D0 is not loaded into the shift register. The PRG
        bits of the control register are also reset to their default values as shown in the next section.
        Usually you will only reset the MMC1 at the very beginning of your program:
        <br />
        <pre>
  LDA #%10000000
STA $8000</pre
        >
        <br /><span class="Apple-style-span" style="font-size: medium"
          ><b> Config Register at $8000-9FFF</b></span
        ><br />
        To load the config register, do 5 writes to the $8000-9FFF range. The config bits are:<br />
        <br />
        <pre>
  43210
-----
CPRMM
|||||
|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
|||               2: vertical; 3: horizontal)
||+--- PRG swap range (0: switch 16 KB bank at $C000; 1: switch 16 KB bank at $8000;
||                            only used when PRG bank mode bit below is set to 1)
|+---- PRG size (0: switch 32 KB at $8000, ignoring low bit of bank number;
|                         1: switch 16 KB at address specified by location bit above)
+----- CHR size (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)</pre
        >
        <br />
        <b>Mirroring Config</b><br />
        Your program can change the mirroring at any point using these bits. You do not need to wait for
        vblank to change them. When using the MMC1 the .inesmir directive bit is ignored. You must set it
        through your code. Mirroring set to 0 and 1 are single screen mirroring modes. Only 1KB is used
        for all nametables. When scrolling the screen will wrap both vertically and horizontally.
        Mirroring set to 2 is the typical vertical mirroring, and 3 is horizontal mirroring.<br />
        <br />
        <b>PRG Bank Size Config</b><br />
        The MMC1 swaps PRG ROM in either 16KB or 32KB chunks. By default this bit is set to 1 for 16KB
        banks. Clearing it to 0 enables 32KB banks. Notice these are not the same size as the 8KB NESASM
        banks so the bank numbers will be different. When using 16KB banks the MMC1 banks are twice as
        big, so you must divide your NESASM bank number by 2 when writing it to the bank register. When
        using 32KB banks you must divide by 4. 16KB banks is most commonly used, with the bulk of the
        code in the fixed bank and data/graphics/music in the swappable banks.<br />
        <br />
        <b>PRG Swap Range Config</b><br />
        When using 16KB banks set above, the PRG address range that gets swapped can be configured. If
        32KB banks are used this bit is ignored and the entire $8000-FFFF range is swapped at once.<br />
        <br />
        By default this bit is set to 1, making the $8000-BFFF range swappable while the $C000-FFFF range
        is fixed to the last bank Of PRG. This matches the PRG swapping of the UNROM mapper and is most
        commonly used. Clearing this bit to 0 changes this so $8000-BFFF is fixed and $C000-FFFF is
        swappable. <br />
        <br />
        Changing the range or bank size can be useful for swapping audio samples but you have to be
        careful to put IRQ/reset/NMI vectors in all banks that are loaded into the vector area at
        $FFFA-FFFF.<br />
        <br />
        <b>CHR Bank Size Config</b><br />
        Like the PRG the CHR bank size can be configured to either 4KB or 8KB banks. With 8KB banks the
        whole $0000-1FFF range is one bank. With 4KB banks there are two banks at PPU $0000-0FFF and
        $1000-1FFF. This can be used with background in one bank and sprites in another. Then, for
        example, all sprites could be swapped and the background could stay.<br />
        <br />
        <br /><span class="Apple-style-span" style="font-size: medium"
          ><b> CHR Bank 0 Register at $A000-BFFF</b></span
        ><br />
        This is the register for CHR bank 0. To set it do 5 writes to the $A000-BFFF range. When in 4KB
        CHR mode it selects a bank for PPU $0000-0FFF. The full 5 bit value is used so there are 32
        possible banks. Each bank is 4KB making it 128KB CHR maximum. When in 8KB CHR mode this register
        controls the full PPU $0000-1FFF. The bottom bit is ignored so there are 16 possible banks. Each
        bank is now 8KB which is still 128KB max.<br />
        <br />
        <div>
          <table style="width: 75%" align="center" border="1">
            <tbody>
              <tr>
                <td width="50%"><b>4KB mode</b></td>
                <td width="50%"><b>8KB mode</b></td>
              </tr>
              <tr>
                <td>controls $0000-0FFF</td>
                <td>controls $0000-1FFF<br />bottom bit is ignored</td>
              </tr>
            </tbody>
          </table>
          <br />
          <span class="Apple-style-span" style="font-size: medium"
            ><b><br /></b
          ></span>
        </div>
        <div>
          <span class="Apple-style-span" style="font-size: medium"
            ><b>CHR Bank 1 Register at $C000-DFFF</b></span
          ><br />
          This is the register for CHR bank 1. To set it do 5 writes to the $C000-DFFF range. When in 4KB
          CHR mode it selects a bank for PPU $1000-1FFF. When in 8KB CHR mode it is completely
          ignored.<br /><br />
        </div>
        <div>
          <table style="width: 75%" align="center" border="1">
            <tbody>
              <tr>
                <td width="50%"><b>4KB mode</b></td>
                <td width="50%"><b>8KB mode</b></td>
              </tr>
              <tr>
                <td>controls $1000-1FFF</td>
                <td>register ignored</td>
              </tr>
            </tbody>
          </table>
          <br /><br /><br /><br />
          <br /><span class="Apple-style-span" style="font-size: medium"
            ><b> PRG Bank Register at $E000-FFFF</b></span
          ><br />
          This is the register for PRG banking. To set it do 5 writes to the $E000-FFFF range. The bits
          are:<br />
          <br />
          <pre>
  43210
-----
WPPPP
|||||
|++++- Select a PRG ROM bank (low bit ignored in 32 KB mode)
+----- WRAM chip enable (0: enabled; 1: disabled)</pre
          >
          <br />
          In 16KB PRG mode it selects a 16KB PRG bank for the current swappable address range. Only the 4
          lower bits are used for 16 possible PRG banks. That is 256KB maximum. In 32KB PRG mode it
          selects a 32KB bank for the $8000-FFFF range. Only bits 3-1 are used for 8 possible banks. Bit
          0 is ignored.&nbsp;
        </div>
        <div><br /></div>
        <div>
          <table style="width: 75%" align="center" border="1">
            <tbody>
              <tr>
                <td width="33%"><b>16KB mode</b><br />swap=0</td>
                <td width="33%"><b>16KB mode</b><br />swap=1</td>
                <td width="33%"><b>32KB mode</b></td>
              </tr>
              <tr>
                <td>controls $C000-FFFF</td>
                <td>controls $8000-BFFF (default setting)</td>
                <td>controls $8000-FFFF<br />low bit ignored</td>
              </tr>
            </tbody>
          </table>
          <br />
          <b><br /></b>
        </div>
        <div>
          <b>WRAM</b><br />
          Bit 5 of the PRG Bank register also controls WRAM access. Clear this bit to enable WRAM access.
          Setting the bit to 1 disables the WRAM. If the WRAM is used for saved games it is usually
          disabled when it is not being accessed to prevent unwanted writes from corrupting the saves
          when the console is reset.<br />
          <br />
          To use WRAM in your program nothing needs to be changed in the iNES header. The emulator will
          assume there is WRAM based on the mapper number. Next you need to enable the WRAM in the PRG
          Bank register. With that bit at 0 you can now use the WRAM. It is just plain RAM that you can
          read or write at the $6000-7FFF range. Like the console RAM the contents are unknown when the
          console is powered on. All RAM is cleared to unknown values when power is removed. However the
          RAM is not cleared when just the reset button is pushed. Power is still going to the cart so
          the RAM is still valid. This can be useful for telling if the console was just turned on or was
          only reset.<br />
          <br />
          To add a battery to the WRAM, set the .inesmir directive to 2 in the iNES header. Now read and
          write to the WRAM normally. When power is removed the RAM contents will remain. The emulator
          will create an 8KB .sav file for the WRAM, however some emulators will not do this unless you
          have done some WRAM access.<br />
          <br />
          <br />
          <span class="Apple-style-span" style="font-size: medium"><b>Banking Routines</b></span
          ><br />
          Keeping track of all the register addresses and bits can get confusing, so a few simple
          routines are used instead. In general subroutines should be used for even simple bank switching
          so the mapper can be changed more easily later. Only the most commonly used Config and PRG Bank
          register routines are shown here, it is your job to write the others.<br />
          <br />
          <pre>ConfigWrite:        ; make sure this is in a fixed PRG bank so the RTS doesn't get swapped away
LDA #$80
STA $8000         ; reset the shift register
LDA #%00001110    ; 8KB CHR, 16KB PRG, $8000-BFFF swappable, vertical mirroring
STA $8000         ; first data bit
LSR A             ; shift to next bit
STA $8000         ; second data bit
LSR A             ; etc
STA $8000
LSR A
STA $8000
LSR A
STA $8000         ; config bits written here, takes effect immediately
RTS<br><br>PRGBankWrite:       ; make sure this is in a fixed bank so it doesnt get swapped away
LDA bankNumber    ; get bank number into A
STA $E000         ; first data bit
LSR A             ; shift to next bit
STA $E000
LSR A
STA $E000
LSR A
STA $E000
LSR A
STA $E000         ; bank switch happens immediately here
RTS</pre>
          <br /><span class="Apple-style-span" style="font-size: medium"
            ><b> Putting It All Together</b></span
          ><br />
          Download and unzip the
          <a
            href="scraper/files/cyoammc1.zip"
            target="_blank"
            original-href="http://www.nespowerpak.com/nesasm/cyoammc1.zip"
            >cyoammc1.zip</a
          >
          sample files. The CYOA code has been changed to the MMC1 mapper. Running the cyoammc1.bat file
          will create cyoammc1.nes, which will run in an emulator. This sample uses 8KB of CHR RAM so no
          CHR banking has been included. The changes from UNROM PRG mapping are minimal. Some of the
          variables have been moved to the WRAM area to show how to use it. An example of using WRAM to
          detect reset is also included in resetCount. Try changing the battery info in the iNES header
          to see how it makes resetCount change between power and resets.<br /><br /><br /><br /><br /><br />
        </div>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="#advanced_tutorial-toc"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Back to Table of Contents
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="javascript:doCommentToggle('advanced_tutorial-1__comments');"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Toggle Comments
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <div style="float: right">
          <a
            class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent"
            href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=33260"
            target="_blank"
            data-upgraded=",MaterialButton,MaterialRipple"
          >
            Original Article
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
          ></a>
        </div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="advanced_tutorial-2">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">Advanced Nerdy Nights #3: Horizontal background scrolling</h2>
      </div>
      <div class="mdl-card__supporting-text">
        <b>This Week:&nbsp;</b>Time to learn how to do horizontal background scrolling, like Super Mario
        Bros. Hopefully it is explained with the most easy to understand code. There is no compression,
        no buffers, and no metatiles, so only the ideas of scrolling are presented. Once you understand
        the scrolling part you should look into those other topics to save code/data space and increase
        performance if needed. <br />
        <br /><br /><br /><span class="Apple-style-span" style="font-size: medium"
          ><b>Nametable Review</b></span
        ><br />
        Before starting the scrolling you must fully understand how nametables work. One nametable is
        32x30 background tiles, which covers exactly one visible screen. Including the attribute table,
        each screen needs 1KB of PPU RAM. The NES PPU has the address space for 4 nametables ($2000,
        $2400, $2800, $2C00) in a 2x2 grid:<br />
        <pre>
       +-----------+-----------+
|           |           |
|           |           |
|   $2000   |   $2400   |
|           |           |
|           |           |
+-----------+-----------+
|           |           |
|           |           |
|   $2800   |   $2C00   |
|           |           |
|           |           |
+-----------+-----------+</pre
        >

        However the NES only has 2KB of PPU RAM inside the console, so there are only two actual
        nametables. The other two nametables are copies of those actual ones. Your mirroring settings
        determine the layout of the actual nametables and which ones are copies. <br />
        <br />
        Vertical mirroring means the nametables stacked vertically are the same data. 0 ($2000) is a
        mirror of 2 ($2800), and 1 ($2400) is a mirror of 3 ($2C00). 0 and 1 are next to each other and
        have different data. This is what we want for horizontal scrolling. When you are looking at
        nametable 0 and scroll to the right, nametable 1 will be in view. Typically your mirroring
        setting is the opposite of the scrolling direction. To set the iNES header:<br />
        <pre>  .inesmir 1  ;;VERT mirroring for HORIZ scrolling</pre>
        <br />
        <span class="Apple-style-span" style="font-size: medium"><b>Scroll registers</b></span
        ><br />
        Before scrolling we will fill both nametables 0 ($2000) and 1 ($2400). The same data will be
        copied into both, except the attribute table will be different. By setting the second nametable
        attributes to another color palette the two screens will have a very visible difference.<br />
        <pre>
FillNametables:
LDA $2002             ; read PPU status to reset the high/low latch
LDA #$20
STA $2006             ; write the high byte of $2000 address (nametable 0)
LDA #$00
STA $2006             ; write the low byte of $2000 address
LDY #$08
LDX #$00              ; fill 256 x 8 bytes = 2KB, both nametables all full
LDA #$7F
FillNametablesLoop:
STA $2007
DEX
BNE FillNametablesLoop
DEY
BNE FillNametablesLoop</pre
        >
        <pre>
FillAttrib0:
LDA $2002             ; read PPU status to reset the high/low latch
LDA #$23
STA $2006             ; write the high byte of $23C0 address (nametable 0 attributes)
LDA #$C0
STA $2006             ; write the low byte of $23C0 address
LDX #$40              ; fill 64 bytes
LDA #$00              ; palette group 0
FillAttrib0Loop:
STA $2007
DEX
BNE FillAttrib0Loop</pre
        >
        <pre>
FillAttrib1:
LDA $2002             ; read PPU status to reset the high/low latch
LDA #$27
STA $2006             ; write the high byte of $27C0 address (nametable 1 attributes)
LDA #$C0
STA $2006             ; write the low byte of $27C0 address
LDX #$40              ; fill 64 bytes
LDA #$FF              ; palette group 3
FillAttrib1Loop:
STA $2007
DEX
BNE FillAttrib1Loop</pre
        >
        The scroll registers are at $2005. Like some other PPU registers you need to write to it twice.
        The first write is the horizontal scroll count, the second write is the vertical scroll count.
        The scroll sets which pixel of the nametable for the start of the left side of the screen.
        Previously we have set the scroll to 0 so the left side of the screen is aligned with the left
        edge of the nametable. The scroll registers are both 8 bit registers, making the scroll range 0
        to 255. The screen is 256 pixels wide so the horizontal scroll register covers one full screen
        wide.<br />
        <br />
        This sample code just increments the horizontal scroll register ($2005) by 1 on every frame. You
        can see when the first nametable scrolls off the screen, the second one comes on screen. The
        previously set colors make the split between nametables obvious. As the scroll register wraps
        from 255 to 0 the first nametable becomes completely visible again. You can also see the sprites
        are not affected by the scroll registers. They have their own separate x and y position data.<br />
        <pre>NMI:
LDA #$00
STA $2003       
LDA #$02
STA $4014       ; sprite DMA from $0200

; run other game graphics updating code here

LDA #$00
STA $2006        ; clean up PPU address registers
STA $2006<br><br>  INC scroll       ; add one to our scroll variable each frame
LDA scroll
STA $2005        ; write the horizontal scroll count register<br><br>  LDA #$00         ; no vertical scrolling
STA $2005

;;This is the PPU clean up section, so rendering the next frame starts properly.
LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
STA $2000
LDA #%00011110   ; enable sprites, enable background, no clipping on left side
STA $2001<br><br>  ; run normal game engine code here
; reading from controllers, etc

RTI              ; return from interrupt</pre>
        <br />
        The full code and compiled .NES file is available from the download link at the bottom of this
        tutorial. scrolling1.asm includes everything up to this point.
        <br /><br /><br />
        <span class="Apple-style-span" style="font-size: medium"><b>Nametable Register</b></span
        ><br />
        The problem with just the scroll register is that it isn't big enough. In the previous example
        the scroll wrapped from 255 to 0, so the second nametable is never shown on the left side. Both
        nametables together is 512 pixels wide but the scroll can only count 256 pixels. The solution is
        to switch which nametable is on the left side of the screen at the same time the scroll register
        wraps to 0.<br />
        <br />
        <img
          src="img/ntA.png"
          original-src="http://www.nespowerpak.com/nesasm/ntA.png"
          show-src="img/ntA.png"
        /><br />
        Vertical mirroring means nametables are arranged horizontally<br />
        <br />
        <img
          src="img/ntB.png"
          original-src="http://www.nespowerpak.com/nesasm/ntB.png"
          show-src="img/ntB.png"
        /><br />
        Scrolling shows nametable 0 and 1 (blue) on the screen (red)<br />
        <br />
        <img
          src="img/ntC.png"
          original-src="http://www.nespowerpak.com/nesasm/ntC.png"
          show-src="img/ntC.png"
        /><br />
        When the scroll register wraps, nametable 0 is displayed again<br />
        <br />
        <img
          src="img/ntD.png"
          original-src="http://www.nespowerpak.com/nesasm/ntD.png"
          show-src="img/ntD.png"
        /><br />
        Swap which nametable is on the left when the wrap happens to display nametable 1<br />
        <br />
        <br />
        To set the starting nametable, change bit 0 of the PPU control register at $2000. Clearing it to
        0 will put nametables 0 and 2 on the left side of the screen with 1 and 3 to the right. Setting
        it to 1 will put 1 and 3 on the left, and 0 and 2 on the right.<br />
        <br />
        This sample code has the same scroll incrementing, but swaps the nametables at the same time the
        scroll wraps from 255 to 0. Instead of the background jumping it continuously scrolls from one
        nametable to the next. When the scroll wraps again the nametables are swapped again and the
        scrolling keeps going.<br />
        <pre>NMI:<br><br>  INC scroll       ; add one to our scroll variable each frame
NTSwapCheck:
LDA scroll       ; check if the scroll just wrapped from 255 to 0
BNE NTSwapCheckDone

NTSwap:
LDA nametable    ; load current nametable number (0 or 1)
EOR #$01         ; exclusive OR of bit 0 will flip that bit
STA nametable    ; so if nametable was 0, now 1
     ;    if nametable was 1, now 0
NTSwapCheckDone:<br><br>  LDA #$00
STA $2003       
LDA #$02
STA $4014       ; sprite DMA from $0200

; run other game graphics updating code here<br><br>  LDA #$00
STA $2006        ; clean up PPU address registers
STA $2006

LDA scroll
STA $2005        ; write the horizontal scroll count register<br><br>  LDA #$00         ; no vertical scrolling
STA $2005

;;This is the PPU clean up section, so rendering the next frame starts properly.
LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
ORA nametable    ; select correct nametable for bit 0
STA $2000

LDA #%00011110   ; enable sprites, enable background, no clipping on left side
STA $2001

; run normal game engine code here
; reading from controllers, etc

RTI              ; return from interrupt</pre>
        <br />
        The full code and compiled .NES file is available from the download link at the bottom of this
        tutorial. scrolling2.asm includes everything up to this point.<br /><br /><br />
        <span class="Apple-style-span" style="font-size: medium"><b>Drawing New Columns</b></span
        ><br />
        For just two screens of graphics the code above is fine. Games like Super Dodgeball use this
        method. Both nametables are filled and scrolled between. For games like SMB where the levels are
        wider than two screens some new background data will have to be inserted. The solution is to draw
        a new vertical column of tiles somewhere off the visible screen, before it is scrolled into the
        visible area. As long as the new column is drawn ahead of the visible area, calculated by the
        current scroll and nametable, it will appear continuous. The tricky part is figuring out which
        column to draw, and where it is to be placed. If we always use the opposite nametable and the
        same scroll point we will be drawing the column that is about to come on screen.<br />
        <br />
        <img
          src="img/ntE.png"
          original-src="http://www.nespowerpak.com/nesasm/ntE.png"
          show-src="img/ntE.png"
        /><br />
        <br /><br />
        &gt;<b>When to Draw</b><br />
        We will draw a new column anytime the scroll register becomes a multiple of 8, meaning the scroll
        is aligned to the tiles. Some bit masking and testing can calculate when this happens. First any
        part of the scroll not 0 to 7 is thrown away. Then if the result equals 0 the scroll count is a
        multiple of 8.<br />
        <pre>
  LDA scroll
AND #%00000111     ; throw away higher bits
BEQ DrawNewColumn  ; see if lower bits = 0</pre
        >
        <br />
        <b>Where to Draw</b><br />
        Now that we know when to draw, we need to calculate the starting PPU address of the new column.
        The scroll register counts in pixels, but we want to count in tiles for which column to draw.
        Each tile is 8 pixels wide, so we divide the scroll by 8 to get the tile number. That number is
        the low bits of the address.<br /><br /><br />
        <pre>
  LDA scroll
LSR A
LSR A
LSR A            ; shift right 3 times = divide by 8
STA columnLow    ; $00 to $1F, screen is 32 tiles wide</pre
        >
        The high bits of the address will come from the current nametable. First the low bit is inverted,
        to get the off screen nametable number. Then the number is shifted up and added to the base
        address.<br />
        <pre>
  LDA nametable
EOR #$01          ; invert low bit, A = $00 or $01
ASL A             ; shift up, A = $00 or $02
ASL A             ; $00 or $04
CLC
ADC #$20          ; add high byte of nametable base address ($2000)
STA columnHigh    ; now address = $20 or $24 for nametable 0 or 1</pre
        >
        Now the scroll count and nametable have been used to make the full column address to start
        copying new background data. It will be at the top of the nametable that is off screen. As the
        scroll and nametable are changed, that calculation will still give the correct starting
        address.<br />
        <br />
        <b>How to Draw</b><br />
        Previously when we have been copying data to the background the PPU is set to auto increment the
        address by 1. That helps with the copying because a whole row of data can be copied while only
        writing the PPU address once. Incrementing by 1 goes to the next horizontal tile. In this case we
        want to go to the next vertical tile because we are copying a column instead of a row. We want it
        to increment by 32 which will jump down instead of across. There are 32 tiles per row, so adding
        32 will always go down to the next row in the same column. The PPU has an increment 32 mode, set
        using bit 2 in the PPU control register at $2000. When bit 2 is set to 0 the increment mode is
        +1. When bit 2 is set to 1 the increment mode is +32. By setting the increment mode to +32 and
        copying 30 bytes of background tiles we can draw one column at a time. <br />
        <pre>
DrawColumn:
LDA #%00000100        ; set to increment +32 mode, don't care about other bits
STA $2000

LDA $2002             ; read PPU status to reset the high/low latch
LDA columnHigh
STA $2006             ; write the high byte of column address
LDA columnLow
STA $2006             ; write the low byte of column address
LDX #$1E              ; copy 30 bytes
LDY #$00
DrawColumnLoop:
LDA columnData, y
STA $2007
INY
DEX
BNE DrawColumnLoop</pre
        >
        <br />
        By using the when/where/how we can draw a new column of data off screen before it becomes
        visible. The full code and compiled .NES file is available from the download link at the bottom
        of this tutorial. scrolling3.asm includes everything up to this point. It will be best to watch
        in an emulator where you can see everything that is off screen. First open the scrolling3.nes
        file in the FCEUXDSP emulator. Then choose "Name Table Viewer..." from the "Tools" menu. Reset
        the emulator and watch the new columns being drawn off the visible screen area. <br /><br />
        <br />
        <b>Drawing Real Background Data</b><br />
        The last example drew new columns, but it wasn't any real data. This example adds another counter
        to keep track of how far along into the level a player is. By incrementing this counter every
        time a new column is drawn the correct next column is easy to find. The DrawNewColumn function
        has been updated to use the counter to load real background data. It can also be used at the
        beginning of the game initialization to populate the starting nametable data instead of using the
        fill loops.<br />
        <br />
        The full code and compiled .NES file is available from the download link at the bottom of this
        tutorial. scrolling4.asm includes 4 screens (128 columns) of real background ripped from SMB.
        <br /><br /><br />
        <span class="Apple-style-span" style="font-size: medium"><b>Updating the Attributes</b></span
        ><br />
        The final piece of the scrolling puzzle is the attribute table. Updating it is the same process
        as the background, where the attributes are updated while they are off screen. Again the scroll
        and nametable registers will be used to calculate the correct attribute bytes to update. Each
        attribute byte covers a 4x4 tile area. 4 tiles wide is 32 pixels, so the attributes must be
        updated anytime the scroll register is a multiple of 32. The column numbers already calculated
        could be used instead of the scroll variables to do the calculations.<br />
        <pre>
  LDA scroll
AND #%00011111     ; check for multiple of 32
BEQ NewAttrib      ; if low 5 bits = 0, time to write new attribute bytes</pre
        >
        Only 8 attribute bytes will need to be changed each time. However they are not sequential, so the
        PPU increment +1 or +32 modes will not work. The PPU address needs to be changed for every
        attribute byte updated. The starting address is the base attribute table at $20C0. Like the
        background address the nametable bit is shifted up and added in. Then the scroll register is
        divided by 32 to get the attribute byte offset. All that is calculated together to find the PPU
        address of the first attribute byte. After that 8 is added to the address for each of the next
        bytes.<br />
        <pre>
  LDA nametable
EOR #$01          ; invert low bit, A = $00 or $01
ASL A             ; shift up, A = $00 or $02
ASL A             ; $00 or $04
CLC
ADC #$20          ; add high byte of attribute base address ($20C0)
STA columnHigh    ; now address = $20 or $24 for nametable 0 or 1

LDA scroll
LSR A
LSR A
LSR A
LSR A
LSR A
CLC
ADC #$C0
STA columnLow     ; attribute base + scroll / 32</pre
        >
        The full code and compiled .NES file is available from the download link at the bottom of this
        tutorial. scrolling5.asm has the same incrementing scroll, but now draws the new column and
        attribute bytes. Use the Name Table Viewer again to check out the attributes being updated. You
        can see the attribute update change the color of the off screen clouds before that column of
        tiles is changed. The same thing is why you see graphical glitches on the sides of SMB3 while it
        is scrolling. To use this in your own game you will need to expand columnNumber to a bigger
        value.<br /><br /><br /><span class="Apple-style-span" style="font-size: medium"
          ><badvanced></badvanced></span
        ><br />
        Once you have understood everything here, there are some more advanced concepts to check out:<br />
        <br />
        <b>Meta Tiles</b> - This idea is to store your backgrounds as bigger blocks instead of individual
        tiles. Things like the question blocks would be stored as one byte in the ROM and then decoded
        into the 4 tiles when it is being drawn. Mostly this saves huge amounts of data space and could
        make updating attributes easier.<br />
        <br />
        <b>Buffers</b> - A section of RAM can be reserved to act as a buffer for the data to draw to the
        PPU later. Outside of vblank where the is more processing time the next graphics updates would be
        calculated and stored in a buffer. Then during vblank those buffers can be dumped right to the
        PPU, saving time. <br />
        <br />
        <b>Compression</b> - Packing the background data into simple compression formats like RLE can
        save even more data space. Combine that with meta tiles and buffers to have a full scrolling
        engine.
        <br />
        <br />
        <span class="Apple-style-span" style="font-size: medium"><b>Putting It All Together</b></span
        ><br />
        Download and unzip the
        <a
          href="scraper/files/scrolling.zip"
          target="_blank"
          original-href="http://www.nespowerpak.com/nesasm/scrolling.zip"
          >scrolling.zip</a
        >
        sample files. Each of them adds a small step, so go through them one at a time. Try expanding the
        background data to add more columns, making the scroll speed variable, or making the scrolling
        controlable.
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="#advanced_tutorial-toc"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Back to Table of Contents
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="javascript:doCommentToggle('advanced_tutorial-2__comments');"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Toggle Comments
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <div style="float: right">
          <a
            class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent"
            href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=36958"
            target="_blank"
            data-upgraded=",MaterialButton,MaterialRipple"
          >
            Original Article
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
          ></a>
        </div>
      </div>
    </div>
    <div class="tutorialCard mdl-card mdl-shadow--2dp" id="advanced_tutorial-3">
      <div class="mdl-card__title">
        <h2 class="mdl-card__title-text">Advanced Nerdy Nights #4: Sprite 0 hit for a status bar</h2>
      </div>
      <div class="mdl-card__supporting-text">
        <b>This Week:</b> After scrolling this tutorial should be pretty simple. Sprite 0 has a special
        PPU flag associated with it. Here it will be used to do split screen scrolling to enable a static
        status bar on the top of the screen.<br />
        <br /><br /><br /><span class="Apple-style-span" style="font-size: medium"
          ><b>Sprite 0 Hit Flag</b></span
        ><br />
        Sprite 0 has a special flag in the PPU status register at bit 6. When a non transparent pixel of
        sprite 0 overlaps a non transparent pixel of the background, the flag is set. In the SMB example,
        sprite 0 is placed at the bottom of the coin icon. That is one part of the status bar that does
        not move.
        <div>
          <br />
          <img
            src="img/sprite0.png"
            original-src="http://www.nespowerpak.com/nesasm/sprite0.png"
            show-src="img/sprite0.png"
          />&nbsp;
          <div>
            <br />
            In our example we first set the scroll registers to 0 for the static status bar. The
            nametable is also set to 0. That makes sure that the background and sprite 0 will overlap in
            the correct place.<br />
            <br /><br />
            <pre>NMI:<br><br>  ; all graphics updating code goes here<br><br>  LDA #$00
STA $2006        ; clean up PPU address registers
STA $2006

LDA #$00         ; start with no scroll for status bar
STA $2005
STA $2005

LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
STA $2000        ; start with nametable = 0 for status bar<br><br>  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
STA $2001</pre>
            Next we make sure the sprite 0 hit flag is clear, to avoid it being tripped from the previous
            frame. The flag is cleared at the end of vblank, so once it equals 0 you know the next frame
            has started.<br />
            <br /><br />
            <pre>
WaitNotSprite0:
lda $2002
and #%01000000
bne WaitNotSprite0   ; wait until sprite 0 not hit</pre
            >
            <br />
            Now we wait until the sprite 0 is hit. How long this takes depends on how far down the screen
            your sprite 0 is placed.<br />
            <br /><br />
            <pre>
WaitSprite0:
lda $2002
and #%01000000
beq WaitSprite0      ; wait until sprite 0 is hit</pre
            >
            <br />
            When that loop finishes, the PPU is drawing the first pixels of sprite 0 that overlap pixels
            on the background. We add a small wait loop so the rest of the status bar is drawn, and then
            change the scroll registers. The rest of the screen down is drawn using those settings.<br /><br /><br />
            <pre>
  ldx #$10
WaitScanline:
dex
bne WaitScanline

LDA scroll
STA $2005        ; write the horizontal scroll count register
LDA #$00         ; no vertical scrolling
STA $2005

LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
ORA nametable    ; select correct nametable for bit 0
STA $2000</pre
            >
            <br />
            So the order is:<br />
            <pre>
  1 - set scroll to 0 for status bar
2 - wait for sprite 0 hit = 0
3 - wait for sprite 0 hit = 1
4 - delay so scanline finishes drawing
5 - set scroll for level background</pre
            >
            <br />
            The only other change is to make sure your graphics updating code does not draw over the
            status bar. The previous DrawNewColumn function handles the graphics updates so it has a few
            small differences. The starting address is increased by $80 to skip the first 4 rows of
            background. Then the source address is increased by $04 for the same reason.
            <br /><br /><br /><br /><span class="Apple-style-span" style="font-size: medium"
              ><b>Putting It All Together</b></span
            ><br />
            Download and unzip the
            <a
              href="scraper/files/sprite0.zip"
              target="_blank"
              original-href="http://www.nespowerpak.com/nesasm/sprite0.zip"
              >sprite0.zip</a
            >
            sample files. sprite0.asm is the same as the previous scrolling5.asm file plus the changes
            covered here. This is another good one to watch in an emulator.
          </div>
        </div>
      </div>
      <div class="mdl-card__actions mdl-card--border">
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="#advanced_tutorial-toc"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Back to Table of Contents
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <a
          class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"
          href="javascript:doCommentToggle('advanced_tutorial-3__comments');"
          data-upgraded=",MaterialButton,MaterialRipple"
        >
          Toggle Comments
          <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
        ></a>
        <div style="float: right">
          <a
            class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect mdl-button--accent"
            href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=36969"
            target="_blank"
            data-upgraded=",MaterialButton,MaterialRipple"
          >
            Original Article
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span
          ></a>
        </div>
      </div>
    </div>
  </body>
</html>
